(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
  * @preserve Qwery - A Blazing Fast query selector engine
  * https://github.com/ded/qwery
  * copyright Dustin Diaz 2012
  * MIT License
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
})('qwery', this, function () {
  var doc = document
    , html = doc.documentElement
    , byClass = 'getElementsByClassName'
    , byTag = 'getElementsByTagName'
    , qSA = 'querySelectorAll'
    , useNativeQSA = 'useNativeQSA'
    , tagName = 'tagName'
    , nodeType = 'nodeType'
    , select // main select() method, assign later

    , id = /#([\w\-]+)/
    , clas = /\.[\w\-]+/g
    , idOnly = /^#([\w\-]+)$/
    , classOnly = /^\.([\w\-]+)$/
    , tagOnly = /^([\w\-]+)$/
    , tagAndOrClass = /^([\w]+)?\.([\w\-]+)$/
    , splittable = /(^|,)\s*[>~+]/
    , normalizr = /^\s+|\s*([,\s\+\~>]|$)\s*/g
    , splitters = /[\s\>\+\~]/
    , splittersMore = /(?![\s\w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^'"]*\]|[\s\w\+\-]*\))/
    , specialChars = /([.*+?\^=!:${}()|\[\]\/\\])/g
    , simple = /^(\*|[a-z0-9]+)?(?:([\.\#]+[\w\-\.#]+)?)/
    , attr = /\[([\w\-]+)(?:([\|\^\$\*\~]?\=)['"]?([ \w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^]+)["']?)?\]/
    , pseudo = /:([\w\-]+)(\(['"]?([^()]+)['"]?\))?/
    , easy = new RegExp(idOnly.source + '|' + tagOnly.source + '|' + classOnly.source)
    , dividers = new RegExp('(' + splitters.source + ')' + splittersMore.source, 'g')
    , tokenizr = new RegExp(splitters.source + splittersMore.source)
    , chunker = new RegExp(simple.source + '(' + attr.source + ')?' + '(' + pseudo.source + ')?')

  var walker = {
      ' ': function (node) {
        return node && node !== html && node.parentNode
      }
    , '>': function (node, contestant) {
        return node && node.parentNode == contestant.parentNode && node.parentNode
      }
    , '~': function (node) {
        return node && node.previousSibling
      }
    , '+': function (node, contestant, p1, p2) {
        if (!node) return false
        return (p1 = previous(node)) && (p2 = previous(contestant)) && p1 == p2 && p1
      }
    }

  function cache() {
    this.c = {}
  }
  cache.prototype = {
    g: function (k) {
      return this.c[k] || undefined
    }
  , s: function (k, v, r) {
      v = r ? new RegExp(v) : v
      return (this.c[k] = v)
    }
  }

  var classCache = new cache()
    , cleanCache = new cache()
    , attrCache = new cache()
    , tokenCache = new cache()

  function classRegex(c) {
    return classCache.g(c) || classCache.s(c, '(^|\\s+)' + c + '(\\s+|$)', 1)
  }

  // not quite as fast as inline loops in older browsers so don't use liberally
  function each(a, fn) {
    var i = 0, l = a.length
    for (; i < l; i++) fn(a[i])
  }

  function flatten(ar) {
    for (var r = [], i = 0, l = ar.length; i < l; ++i) arrayLike(ar[i]) ? (r = r.concat(ar[i])) : (r[r.length] = ar[i])
    return r
  }

  function arrayify(ar) {
    var i = 0, l = ar.length, r = []
    for (; i < l; i++) r[i] = ar[i]
    return r
  }

  function previous(n) {
    while (n = n.previousSibling) if (n[nodeType] == 1) break;
    return n
  }

  function q(query) {
    return query.match(chunker)
  }

  // called using `this` as element and arguments from regex group results.
  // given => div.hello[title="world"]:foo('bar')
  // div.hello[title="world"]:foo('bar'), div, .hello, [title="world"], title, =, world, :foo('bar'), foo, ('bar'), bar]
  function interpret(whole, tag, idsAndClasses, wholeAttribute, attribute, qualifier, value, wholePseudo, pseudo, wholePseudoVal, pseudoVal) {
    var i, m, k, o, classes
    if (this[nodeType] !== 1) return false
    if (tag && tag !== '*' && this[tagName] && this[tagName].toLowerCase() !== tag) return false
    if (idsAndClasses && (m = idsAndClasses.match(id)) && m[1] !== this.id) return false
    if (idsAndClasses && (classes = idsAndClasses.match(clas))) {
      for (i = classes.length; i--;) if (!classRegex(classes[i].slice(1)).test(this.className)) return false
    }
    if (pseudo && qwery.pseudos[pseudo] && !qwery.pseudos[pseudo](this, pseudoVal)) return false
    if (wholeAttribute && !value) { // select is just for existance of attrib
      o = this.attributes
      for (k in o) {
        if (Object.prototype.hasOwnProperty.call(o, k) && (o[k].name || k) == attribute) {
          return this
        }
      }
    }
    if (wholeAttribute && !checkAttr(qualifier, getAttr(this, attribute) || '', value)) {
      // select is for attrib equality
      return false
    }
    return this
  }

  function clean(s) {
    return cleanCache.g(s) || cleanCache.s(s, s.replace(specialChars, '\\$1'))
  }

  function checkAttr(qualify, actual, val) {
    switch (qualify) {
    case '=':
      return actual == val
    case '^=':
      return actual.match(attrCache.g('^=' + val) || attrCache.s('^=' + val, '^' + clean(val), 1))
    case '$=':
      return actual.match(attrCache.g('$=' + val) || attrCache.s('$=' + val, clean(val) + '$', 1))
    case '*=':
      return actual.match(attrCache.g(val) || attrCache.s(val, clean(val), 1))
    case '~=':
      return actual.match(attrCache.g('~=' + val) || attrCache.s('~=' + val, '(?:^|\\s+)' + clean(val) + '(?:\\s+|$)', 1))
    case '|=':
      return actual.match(attrCache.g('|=' + val) || attrCache.s('|=' + val, '^' + clean(val) + '(-|$)', 1))
    }
    return 0
  }

  // given a selector, first check for simple cases then collect all base candidate matches and filter
  function _qwery(selector, _root) {
    var r = [], ret = [], i, l, m, token, tag, els, intr, item, root = _root
      , tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr))
      , dividedTokens = selector.match(dividers)

    if (!tokens.length) return r

    token = (tokens = tokens.slice(0)).pop() // copy cached tokens, take the last one
    if (tokens.length && (m = tokens[tokens.length - 1].match(idOnly))) root = byId(_root, m[1])
    if (!root) return r

    intr = q(token)
    // collect base candidates to filter
    els = root !== _root && root[nodeType] !== 9 && dividedTokens && /^[+~]$/.test(dividedTokens[dividedTokens.length - 1]) ?
      function (r) {
        while (root = root.nextSibling) {
          root[nodeType] == 1 && (intr[1] ? intr[1] == root[tagName].toLowerCase() : 1) && (r[r.length] = root)
        }
        return r
      }([]) :
      root[byTag](intr[1] || '*')
    // filter elements according to the right-most part of the selector
    for (i = 0, l = els.length; i < l; i++) {
      if (item = interpret.apply(els[i], intr)) r[r.length] = item
    }
    if (!tokens.length) return r

    // filter further according to the rest of the selector (the left side)
    each(r, function (e) { if (ancestorMatch(e, tokens, dividedTokens)) ret[ret.length] = e })
    return ret
  }

  // compare element to a selector
  function is(el, selector, root) {
    if (isNode(selector)) return el == selector
    if (arrayLike(selector)) return !!~flatten(selector).indexOf(el) // if selector is an array, is el a member?

    var selectors = selector.split(','), tokens, dividedTokens
    while (selector = selectors.pop()) {
      tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr))
      dividedTokens = selector.match(dividers)
      tokens = tokens.slice(0) // copy array
      if (interpret.apply(el, q(tokens.pop())) && (!tokens.length || ancestorMatch(el, tokens, dividedTokens, root))) {
        return true
      }
    }
    return false
  }

  // given elements matching the right-most part of a selector, filter out any that don't match the rest
  function ancestorMatch(el, tokens, dividedTokens, root) {
    var cand
    // recursively work backwards through the tokens and up the dom, covering all options
    function crawl(e, i, p) {
      while (p = walker[dividedTokens[i]](p, e)) {
        if (isNode(p) && (interpret.apply(p, q(tokens[i])))) {
          if (i) {
            if (cand = crawl(p, i - 1, p)) return cand
          } else return p
        }
      }
    }
    return (cand = crawl(el, tokens.length - 1, el)) && (!root || isAncestor(cand, root))
  }

  function isNode(el, t) {
    return el && typeof el === 'object' && (t = el[nodeType]) && (t == 1 || t == 9)
  }

  function uniq(ar) {
    var a = [], i, j;
    o:
    for (i = 0; i < ar.length; ++i) {
      for (j = 0; j < a.length; ++j) if (a[j] == ar[i]) continue o
      a[a.length] = ar[i]
    }
    return a
  }

  function arrayLike(o) {
    return (typeof o === 'object' && isFinite(o.length))
  }

  function normalizeRoot(root) {
    if (!root) return doc
    if (typeof root == 'string') return qwery(root)[0]
    if (!root[nodeType] && arrayLike(root)) return root[0]
    return root
  }

  function byId(root, id, el) {
    // if doc, query on it, else query the parent doc or if a detached fragment rewrite the query and run on the fragment
    return root[nodeType] === 9 ? root.getElementById(id) :
      root.ownerDocument &&
        (((el = root.ownerDocument.getElementById(id)) && isAncestor(el, root) && el) ||
          (!isAncestor(root, root.ownerDocument) && select('[id="' + id + '"]', root)[0]))
  }

  function qwery(selector, _root) {
    var m, el, root = normalizeRoot(_root)

    // easy, fast cases that we can dispatch with simple DOM calls
    if (!root || !selector) return []
    if (selector === window || isNode(selector)) {
      return !_root || (selector !== window && isNode(root) && isAncestor(selector, root)) ? [selector] : []
    }
    if (selector && arrayLike(selector)) return flatten(selector)
    if (m = selector.match(easy)) {
      if (m[1]) return (el = byId(root, m[1])) ? [el] : []
      if (m[2]) return arrayify(root[byTag](m[2]))
      if (hasByClass && m[3]) return arrayify(root[byClass](m[3]))
    }

    return select(selector, root)
  }

  // where the root is not document and a relationship selector is first we have to
  // do some awkward adjustments to get it to work, even with qSA
  function collectSelector(root, collector) {
    return function (s) {
      var oid, nid
      if (splittable.test(s)) {
        if (root[nodeType] !== 9) {
          // make sure the el has an id, rewrite the query, set root to doc and run it
          if (!(nid = oid = root.getAttribute('id'))) root.setAttribute('id', nid = '__qwerymeupscotty')
          s = '[id="' + nid + '"]' + s // avoid byId and allow us to match context element
          collector(root.parentNode || root, s, true)
          oid || root.removeAttribute('id')
        }
        return;
      }
      s.length && collector(root, s, false)
    }
  }

  var isAncestor = 'compareDocumentPosition' in html ?
    function (element, container) {
      return (container.compareDocumentPosition(element) & 16) == 16
    } : 'contains' in html ?
    function (element, container) {
      container = container[nodeType] === 9 || container == window ? html : container
      return container !== element && container.contains(element)
    } :
    function (element, container) {
      while (element = element.parentNode) if (element === container) return 1
      return 0
    }
  , getAttr = function () {
      // detect buggy IE src/href getAttribute() call
      var e = doc.createElement('p')
      return ((e.innerHTML = '<a href="#x">x</a>') && e.firstChild.getAttribute('href') != '#x') ?
        function (e, a) {
          return a === 'class' ? e.className : (a === 'href' || a === 'src') ?
            e.getAttribute(a, 2) : e.getAttribute(a)
        } :
        function (e, a) { return e.getAttribute(a) }
    }()
  , hasByClass = !!doc[byClass]
    // has native qSA support
  , hasQSA = doc.querySelector && doc[qSA]
    // use native qSA
  , selectQSA = function (selector, root) {
      var result = [], ss, e
      try {
        if (root[nodeType] === 9 || !splittable.test(selector)) {
          // most work is done right here, defer to qSA
          return arrayify(root[qSA](selector))
        }
        // special case where we need the services of `collectSelector()`
        each(ss = selector.split(','), collectSelector(root, function (ctx, s) {
          e = ctx[qSA](s)
          if (e.length == 1) result[result.length] = e.item(0)
          else if (e.length) result = result.concat(arrayify(e))
        }))
        return ss.length > 1 && result.length > 1 ? uniq(result) : result
      } catch (ex) { }
      return selectNonNative(selector, root)
    }
    // no native selector support
  , selectNonNative = function (selector, root) {
      var result = [], items, m, i, l, r, ss
      selector = selector.replace(normalizr, '$1')
      if (m = selector.match(tagAndOrClass)) {
        r = classRegex(m[2])
        items = root[byTag](m[1] || '*')
        for (i = 0, l = items.length; i < l; i++) {
          if (r.test(items[i].className)) result[result.length] = items[i]
        }
        return result
      }
      // more complex selector, get `_qwery()` to do the work for us
      each(ss = selector.split(','), collectSelector(root, function (ctx, s, rewrite) {
        r = _qwery(s, ctx)
        for (i = 0, l = r.length; i < l; i++) {
          if (ctx[nodeType] === 9 || rewrite || isAncestor(r[i], root)) result[result.length] = r[i]
        }
      }))
      return ss.length > 1 && result.length > 1 ? uniq(result) : result
    }
  , configure = function (options) {
      // configNativeQSA: use fully-internal selector or native qSA where present
      if (typeof options[useNativeQSA] !== 'undefined')
        select = !options[useNativeQSA] ? selectNonNative : hasQSA ? selectQSA : selectNonNative
    }

  configure({ useNativeQSA: true })

  qwery.configure = configure
  qwery.uniq = uniq
  qwery.is = is
  qwery.pseudos = {}

  return qwery
});

},{}],2:[function(require,module,exports){
/***************************************************************
  * Traversty: A DOM collection management and traversal utility
  * (c) Rod Vagg (@rvagg) 2012
  * https://github.com/rvagg/traversty
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else if (typeof define == 'function' && define.amd)
    define(definition)
  else
    context[name] = definition()
})('traversty', this, function () {

  var context = this
    , old = context.traversty
    , doc = window.document
    , html = doc.documentElement
    , toString = Object.prototype.toString
    , Ap = Array.prototype
    , slice = Ap.slice
      // feature test to find native matchesSelector()
    , matchesSelector = (function (el, pfx, name, i, ms) {
        while (i < pfx.length)
          if (el[ms = pfx[i++] + name])
            return ms
      }(html, [ 'msM', 'webkitM', 'mozM', 'oM', 'm' ], 'atchesSelector', 0))

    , Kfalse = function () { return false }

    , isNumber = function (o) {
        return toString.call(o) === '[object Number]'
      }

    , isString = function (o) {
        return toString.call(o) === '[object String]'
      }

    , isFunction = function (o) {
        return toString.call(o) === '[object Function]'
      }

    , isUndefined = function (o) {
        return o === void 0
      }

    , isElement = function (o) {
        return o && o.nodeType === 1
      }

      // figure out which argument, if any, is our 'index'
    , getIndex = function (selector, index) {
        return isUndefined(selector) && !isNumber(index) ? 0 :
          isNumber(selector) ? selector : isNumber(index) ? index : null
      }

      // figure out which argument, if any, is our 'selector'
    , getSelector = function (selector) {
        return isString(selector) ? selector : '*'
      }

    , nativeSelectorFind = function (selector, el) {
        return slice.call(el.querySelectorAll(selector), 0)
      }

    , nativeSelectorMatches = function (selector, el) {
        return selector === '*' || el[matchesSelector](selector)
      }

    , selectorFind = nativeSelectorFind

    , selectorMatches = nativeSelectorMatches

      // used in the case where our selector engine does out-of-order element returns for
      // grouped selectors, e.g. '.class, tag', we need our elements in document-order
      // so we do it ourselves if need be
    , createUnorderedEngineSelectorFind = function(engineSelect, selectorMatches) {
        return function (selector, el) {
          if (/,/.test(selector)) {
            var ret = [], i = -1, els = el.getElementsByTagName('*')
            while (++i < els.length)
              if (isElement(els[i]) && selectorMatches(selector, els[i]))
                ret.push(els[i])
            return ret
          }
          return engineSelect(selector, el)
        }
      }

      // is 'element' underneath 'container' somewhere
    , isAncestor = 'compareDocumentPosition' in html
        ? function (element, container) {
            return (container.compareDocumentPosition(element) & 16) == 16
          }
        : 'contains' in html
          ? function (element, container) {
              container = container.nodeType === 9 || container == window ? html : container
              return container !== element && container.contains(element)
            }
          : function (element, container) { // old smelly browser
              while (element = element.parentNode)
                if (element === container)
                  return 1
              return 0
            }

      // return an array containing only unique elements
    , unique = function (ar) {
        var a = [], i = -1, j, has
        while (++i < ar.length) {
          j = -1
          has = false
          while (++j < a.length) {
            if (a[j] === ar[i]) {
              has = true
              break
            }
          }
          if (!has)
            a.push(ar[i])
        }
        return a
      }

      // for each element of 'els' execute 'fn' to get an array of elements to collect
    , collect = function (els, fn) {
        var ret = [], res, i = 0, j, l = els.length, l2
        while (i < l) {
          j = 0
          l2 = (res = fn(els[i], i++)).length
          while (j < l2)
            ret.push(res[j++])
        }
        return ret
      }

     // generic DOM navigator to move multiple elements around the DOM
   , move = function (els, method, selector, index, filterFn) {
        index = getIndex(selector, index)
        selector = getSelector(selector)
        return collect(els
          , function (el, elind) {
              var i = index || 0, ret = []
              if (!filterFn)
                el = el[method]
              while (el && (index === null || i >= 0)) {
                // ignore non-elements, only consider selector-matching elements
                // handle both the index and no-index (selector-only) cases
                if (isElement(el)
                    && (!filterFn || filterFn === true || filterFn(el, elind))
                    && selectorMatches(selector, el)
                    && (index === null || i-- === 0)) {
                  // this concat vs push is to make sure we add elements to the result array
                  // in reverse order when doing a previous(selector) and up(selector)
                  index === null
                      && method != 'nextSibling'
                      && method != 'parentNode'
                    ? ret.unshift(el)
                    : ret.push(el)
                }
                el = el[method]
              }
              return ret
            }
        )
      }

      // given an index & length, return a 'fixed' index, fixes non-numbers & neative indexes
    , eqIndex = function (length, index, def) {
        if (index < 0)
          index = length + index
        if (index < 0 || index >= length)
          return null
        return !index && index !== 0 ? def : index
      }

      // collect elements of an array that match a filter function
    , filter = function (els, fn) {
        var arr = [], i = 0, l = els.length
        for (; i < l; i++)
          if (fn(els[i], i))
            arr.push(els[i])
        return arr
      }

      // create a filter function, for use by filter(), is() & not()
      // allows the argument to be an element, a function or a selector
    , filterFn = function (slfn) {
        var to
        return isElement(slfn)
          ? function (el) { return el === slfn }
          : (to = typeof slfn) == 'function'
            ? function (el, i) { return slfn.call(el, i) }
            : to == 'string' && slfn.length
              ? function (el) { return selectorMatches(slfn, el) }
              : Kfalse
      }

      // fn = !fn
    , inv = function (fn) {
        return function () {
          return !fn.apply(this, arguments)
        }
      }

    , traversty = (function () {
        function T(els) {
          this.length = 0
          if (els) {
            els = unique(!els.nodeType && !isUndefined(els.length) ? els : [ els ])
            var i = this.length = els.length
            while (i--)
              this[i] = els[i]
          }
        }

        T.prototype = {
            down: function (selector, index) {
              index = getIndex(selector, index)
              selector = getSelector(selector)
              return traversty(collect(this
                , function (el) {
                    var f = selectorFind(selector, el)
                    return index === null ? f : ([ f[index] ] || [])
                  }
                ))
            }

          , up: function (selector, index) {
              return traversty(move(this, 'parentNode', selector, index))
            }

          , parents: function () {
              return T.prototype.up.apply(this, arguments.length ? arguments : [ '*' ])
            }

          , closest: function (selector, index) {
              if (isNumber(selector)) {
                index = selector
                selector = '*'
              } else if (!isString(selector)) {
                return traversty([])
              } else if (!isNumber(index)) {
                index = 0
              }
              return traversty(move(this, 'parentNode', selector, index, true))
            }

          , previous: function (selector, index) {
              return traversty(move(this, 'previousSibling', selector, index))
            }

          , next: function (selector, index) {
              return traversty(move(this, 'nextSibling', selector, index))
            }

          , siblings: function (selector, index) {
              var self = this
                , arr = slice.call(this, 0)
                , i = 0, l = arr.length

              for (; i < l; i++) {
                arr[i] = arr[i].parentNode.firstChild
                while (!isElement(arr[i]))
                  arr[i] = arr[i].nextSibling
              }

              if (isUndefined(selector))
                selector = '*'

              return traversty(move(arr, 'nextSibling', selector || '*', index
                    , function (el, i) { return el !== self[i] } // filter
                  ))
            }

          , children: function (selector, index) {
              return traversty(move(T.prototype.down.call(this), 'nextSibling', selector || '*', index, true))
            }

          , first: function () {
              return T.prototype.eq.call(this, 0)
            }

          , last: function () {
              return T.prototype.eq.call(this, -1)
            }

          , eq: function (index) {
              return traversty(this.get(index))
            }

          , get: function (index) {
              return this[eqIndex(this.length, index, 0)]
            }

            // a crazy man wrote this, don't try to understand it, see the tests
          , slice: function (start, end) {
              var e = end, l = this.length, arr = []
              start = eqIndex(l, Math.max(-this.length, start), 0)
              e = eqIndex(end < 0 ? l : l + 1, end, l)
              end = e === null || e > l ? end < 0 ? 0 : l : e
              while (start !== null && start < end)
                arr.push(this[start++])
              return traversty(arr)
            }

          , filter: function (slfn) {
              return traversty(filter(this, filterFn(slfn)))
            }

          , not: function (slfn) {
              return traversty(filter(this, inv(filterFn(slfn))))
            }

            // similar to filter() but cares about descendent elements
          , has: function (slel) {
              return traversty(filter(
                  this
                , isElement(slel)
                    ? function (el) { return isAncestor(slel, el) }
                    : typeof slel == 'string' && slel.length
                      ? function (el) { return selectorFind(slel, el).length } //TODO: performance
                      : Kfalse
              ))
            }

            // same as filter() but return a boolean so quick-return after first successful find
          , is: function (slfn) {
              var i = 0, l = this.length
                , fn = filterFn(slfn)
              for (; i < l; i++)
                if (fn(this[i], i))
                  return true
              return false
            }

          , toArray: function () { return Ap.slice.call(this) }

          , size: function () { return this.length }

          , each: function (fn, ctx) {
              var i = 0, l = this.length
              for (; i < l; i++)
                fn.call(ctx || this[i], this[i], i, this)
              return this
            }

            // quack like a duck (Array)
          , push: Ap.push
          , sort: Ap.sort
          , splice: Ap.splice
        }

        T.prototype.prev = T.prototype.previous

        function t(els) {
          return new T(isString(els) ? selectorFind(els, doc) : els)
        }

        // extend traversty functionality with custom methods
        t.aug = function (methods) {
          var key, method
          for (key in methods) {
            method = methods[key]
            if (typeof method == 'function')
              T.prototype[key] = method
          }
        }


        t.setSelectorEngine = function (s) {
          // feature testing the selector engine like a boss
          var ss, r, a, _selectorMatches, _selectorFind
            , e = doc.createElement('p')
            , select = s.select || s.sel || s

          e.innerHTML = '<a/><i/><b/>'
          a = e.firstChild
          try {
            // YO! I HEARD YOU LIKED NESTED TERNARY OPERATORS SO I COOKED SOME UP FOR YOU!
            // (one day I might loop this...)

            // check to see how we do a matchesSelector
            _selectorMatches = isFunction(s.matching)
              ? function (selector, el) { return s.matching([el], selector).length > 0 }
              : isFunction(s.is)
                ? function (selector, el) { return s.is(el, selector) }
                : isFunction(s.matchesSelector)
                  ? function (selector, el) { return s.matchesSelector(el, selector) }
                  : isFunction(s.match)
                    ? function (selector, el) { return s.match(el, selector) }
                    : isFunction(s.matches)
                      ? function (selector, el) { return s.matches(el, selector) }
                      : null

            if (!_selectorMatches) {
              // perhaps it's an selector(x).is(y) type selector?
              ss = s('a', e)
              _selectorMatches = isFunction(ss._is)
                ? function (selector, el) { return s(el)._is(selector) } // original .is(), replaced by Ender bridge
                : isFunction(ss.matching)
                  ? function (selector, el) { return s(el).matching(selector).length > 0 }
                  : isFunction(ss.is) && !ss.is.__ignore
                    ? function (selector, el) { return s(el).is(selector) }
                      : isFunction(ss.matchesSelector)
                        ? function (selector, el) { return s(el).matchesSelector(selector) }
                        : isFunction(ss.match)
                          ? function (selector, el) { return s(el).match(selector) }
                          : isFunction(ss.matches)
                            ? function (selector, el) { return s(el).matches(selector) }
                            : null
            }

            if (!_selectorMatches)
                throw new Error('Traversty: couldn\'t find selector engine\'s `matchesSelector`')

            // verify that we have a working `matchesSelector`
            if (_selectorMatches('x,y', e) || !_selectorMatches('a,p', e))
                throw new Error('Traversty: couldn\'t make selector engine\'s `matchesSelector` work')

            // basic select
            if ((r = select('b,a', e)).length !== 2)
              throw new Error('Traversty: don\'t know how to use this selector engine')

            // check to see if the selector engine has given us the results in document-order
            // and if not, work around it
            _selectorFind = r[0] === a ? select : createUnorderedEngineSelectorFind(select, _selectorMatches)

            // have we done enough to get a working `selectorFind`?
            if ((r = _selectorFind('b,a', e)).length !== 2 || r[0] !== a)
              throw new Error('Traversty: couldn\'t make selector engine work')

            selectorMatches = _selectorMatches
            selectorFind = _selectorFind
          } catch (ex) {
            throw isString(ex)
              ? ex
              : new Error('Traversty: error while figuring out how the selector engine works: ' + (ex.message || ex))
          } finally {
            e = null
          }

          return t
        }

        t.noConflict = function () {
          context.traversty = old
          return this
        }

        return t
      }())
 
  return traversty
});
},{}],3:[function(require,module,exports){
/* ==========================================================================
   Log.js - Lightweight wrapper for console.log

   Usage: log('inside coolFunc', this, arguments);
   * paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/
   ========================================================================== */
window.log = function f() {
	log.history = log.history || [];
	log.history.push(arguments);
	if (this.console) {
		var args = arguments,
			newarr;
		try {
			args.callee = f.caller;
		} catch (e) {}
		newarr = [].slice.call(args);
		if (typeof console.log === 'object')  {
			log.apply.call(console.log, console, newarr);
		} else {
			console.log.apply(console, newarr);
		}
	}
};

},{}],4:[function(require,module,exports){
/*! 
Included shims: Array.forEach,Array.filter,Array.map,Function.bind,EventListener,Element.classList
*/

/*
    Array.prototype.forEach()
*/
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(t, e) {
        var n, r;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var i = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var o = i.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof t !== "function") {
            throw new TypeError(t + " is not a function");
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (e) {
            n = e;
        }
        // 6. Let k be 0
        r = 0;
        // 7. Repeat, while k < len
        while (r < o) {
            var a;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (r in i) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                a = i[r];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                t.call(n, a, r, i);
            }
            // d. Increase k by 1.
            r++;
        }
    };
}

/*
    Array.prototype.filter()
*/
if (!Array.prototype.filter) {
    Array.prototype.filter = function(t) {
        "use strict";
        if (this === void 0 || this === null) throw new TypeError();
        var e = Object(this);
        var n = e.length >>> 0;
        if (typeof t !== "function") throw new TypeError();
        var r = [];
        var i = arguments.length >= 2 ? arguments[1] : void 0;
        for (var o = 0; o < n; o++) {
            if (o in e) {
                var a = e[o];
                // NOTE: Technically this should Object.defineProperty at
                //       the next index, as push can be affected by
                //       properties on Object.prototype and Array.prototype.
                //       But that method's new, and collisions should be
                //       rare, so use the more-compatible alternative.
                if (t.call(i, a, o, e)) r.push(a);
            }
        }
        return r;
    };
}

/*
   Array map patch
   ========================================================================== */
if (!("map" in Array.prototype)) {
    Array.prototype.map = function(t, e) {
        var n = this.length >>> 0, r = Array(n);
        for (var i = 0; i < n; i++) {
            if (i in this) {
                r[i] = t.call(e, this[i], i, this);
            }
        }
        return r;
    };
}

/*
    Function.prototype.bind()
*/
if (!Function.prototype.bind) {
    Function.prototype.bind = function(t) {
        if (typeof this !== "function") {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var e = Array.prototype.slice.call(arguments, 1), n = this, r = function() {}, i = function() {
            return n.apply(this instanceof r && t ? this : t, e.concat(Array.prototype.slice.call(arguments)));
        };
        r.prototype = this.prototype;
        i.prototype = new r();
        return i;
    };
}

// EventListener | MIT/GPL2 | https://github.com/jonathantneal/EventListener
this.Element && Element.prototype.attachEvent && !Element.prototype.addEventListener && function() {
    function t(t, e) {
        Window.prototype[t] = HTMLDocument.prototype[t] = Element.prototype[t] = e;
    }
    // add
    t("addEventListener", function(t, e) {
        var n = this, r = n.addEventListener.listeners = n.addEventListener.listeners || {}, i = r[t] = r[t] || [];
        // if no events exist, attach the listener
        if (!i.length) {
            n.attachEvent("on" + t, i.event = function(t) {
                var e = n.document && n.document.documentElement || n.documentElement || {
                    scrollLeft: 0,
                    scrollTop: 0
                };
                // polyfill w3c properties and methods
                t.currentTarget = n;
                t.pageX = t.clientX + e.scrollLeft;
                t.pageY = t.clientY + e.scrollTop;
                t.preventDefault = function() {
                    t.returnValue = false;
                };
                t.relatedTarget = t.fromElement || null;
                t.stopImmediatePropagation = function() {
                    s = false;
                    t.cancelBubble = true;
                };
                t.stopPropagation = function() {
                    t.cancelBubble = true;
                };
                t.target = t.srcElement || n;
                t.timeStamp = +new Date();
                // create an cached list of the master events list (to protect this loop from breaking when an event is removed)
                for (var r = 0, o = [].concat(i), a, s = true; s && (a = o[r]); ++r) {
                    // check to see if the cached event still exists in the master events list
                    for (var l = 0, c; c = i[l]; ++l) {
                        if (c == a) {
                            c.call(n, t);
                            break;
                        }
                    }
                }
            });
        }
        // add the event to the master event list
        i.push(e);
    });
    // remove
    t("removeEventListener", function(t, e) {
        var n = this, r = n.addEventListener.listeners = n.addEventListener.listeners || {}, i = r[t] = r[t] || [];
        // remove the newest matching event from the master event list
        for (var o = i.length - 1, a; a = i[o]; --o) {
            if (a == e) {
                i.splice(o, 1);
                break;
            }
        }
        // if no events exist, detach the listener
        if (!i.length && i.event) {
            n.detachEvent("on" + t, i.event);
        }
    });
    // dispatch
    t("dispatchEvent", function(t) {
        var e = this, n = t.type, r = e.addEventListener.listeners = e.addEventListener.listeners || {}, i = r[n] = r[n] || [];
        try {
            return e.fireEvent("on" + n, t);
        } catch (o) {
            if (i.event) {
                i.event(t);
            }
            return;
        }
    });
    // CustomEvent
    Object.defineProperty(Window.prototype, "CustomEvent", {
        get: function() {
            var t = this;
            return function e(n, r) {
                var i = t.document.createEventObject(), o;
                i.type = n;
                for (o in r) {
                    if (o == "cancelable") {
                        i.returnValue = !r.cancelable;
                    } else if (o == "bubbles") {
                        i.cancelBubble = !r.bubbles;
                    } else if (o == "detail") {
                        i.detail = r.detail;
                    }
                }
                return i;
            };
        }
    });
    // ready
    function e(t) {
        if (e.interval && document.body) {
            e.interval = clearInterval(e.interval);
            document.dispatchEvent(new CustomEvent("DOMContentLoaded"));
        }
    }
    e.interval = setInterval(e, 1);
    window.addEventListener("load", e);
}();

!this.CustomEvent && function() {
    // CustomEvent for browsers which don't natively support the Constructor method
    window.CustomEvent = function t(e, n) {
        var r;
        n = n || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };
        try {
            r = document.createEvent("CustomEvent");
            r.initCustomEvent(e, n.bubbles, n.cancelable, n.detail);
        } catch (i) {
            // for browsers which don't support CustomEvent at all, we use a regular event instead
            r = document.createEvent("Event");
            r.initEvent(e, n.bubbles, n.cancelable);
            r.detail = n.detail;
        }
        return r;
    };
}();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 2014-01-31
 *
 * By Eli Grey, http://eligrey.com
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */
/*global self, document, DOMException */
/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/
if ("document" in self && !("classList" in document.createElement("_"))) {
    (function(t) {
        "use strict";
        if (!("Element" in t)) return;
        var e = "classList", n = "prototype", r = t.Element[n], i = Object, o = String[n].trim || function() {
            return this.replace(/^\s+|\s+$/g, "");
        }, a = Array[n].indexOf || function(t) {
            var e = 0, n = this.length;
            for (;e < n; e++) {
                if (e in this && this[e] === t) {
                    return e;
                }
            }
            return -1;
        }, s = function(t, e) {
            this.name = t;
            this.code = DOMException[t];
            this.message = e;
        }, l = function(t, e) {
            if (e === "") {
                throw new s("SYNTAX_ERR", "An invalid or illegal string was specified");
            }
            if (/\s/.test(e)) {
                throw new s("INVALID_CHARACTER_ERR", "String contains an invalid character");
            }
            return a.call(t, e);
        }, c = function(t) {
            var e = o.call(t.getAttribute("class") || ""), n = e ? e.split(/\s+/) : [], r = 0, i = n.length;
            for (;r < i; r++) {
                this.push(n[r]);
            }
            this._updateClassName = function() {
                t.setAttribute("class", this.toString());
            };
        }, u = c[n] = [], f = function() {
            return new c(this);
        };
        // Most DOMException implementations don't allow calling DOMException's toString()
        // on non-DOMExceptions. Error's toString() is sufficient here.
        s[n] = Error[n];
        u.item = function(t) {
            return this[t] || null;
        };
        u.contains = function(t) {
            t += "";
            return l(this, t) !== -1;
        };
        u.add = function() {
            var t = arguments, e = 0, n = t.length, r, i = false;
            do {
                r = t[e] + "";
                if (l(this, r) === -1) {
                    this.push(r);
                    i = true;
                }
            } while (++e < n);
            if (i) {
                this._updateClassName();
            }
        };
        u.remove = function() {
            var t = arguments, e = 0, n = t.length, r, i = false;
            do {
                r = t[e] + "";
                var o = l(this, r);
                if (o !== -1) {
                    this.splice(o, 1);
                    i = true;
                }
            } while (++e < n);
            if (i) {
                this._updateClassName();
            }
        };
        u.toggle = function(t, e) {
            t += "";
            var n = this.contains(t), r = n ? e !== true && "remove" : e !== false && "add";
            if (r) {
                this[r](t);
            }
            return !n;
        };
        u.toString = function() {
            return this.join(" ");
        };
        if (i.defineProperty) {
            var p = {
                get: f,
                enumerable: true,
                configurable: true
            };
            try {
                i.defineProperty(r, e, p);
            } catch (h) {
                // IE 8 doesn't support enumerable:true
                if (h.number === -2146823252) {
                    p.enumerable = false;
                    i.defineProperty(r, e, p);
                }
            }
        } else if (i[n].__defineGetter__) {
            r.__defineGetter__(e, f);
        }
    })(self);
}
},{}],5:[function(require,module,exports){
/*
	sockets.js
*/

// dependencies for this module go here
var UI = require('./ui');

var Sockets = {
	socket : null,

	init : function () {
		this.makeSocketConnection();

		this.Listeners.setup();
	},

	makeSocketConnection : function () {

		var connectionURL = window.location.hostname;

		this.socket = io.connect(connectionURL);

	},

	Listeners : {

		setup : function () {

			Sockets.socket.on('tweet', this.onTweetReceived);

		},

		onTweetReceived : function (symbolObj) {

			UI.updateSymbol(symbolObj.key, symbolObj.symbol);

		}

	}


};

module.exports = Sockets;
},{"./ui":6}],6:[function(require,module,exports){
/*
	UI.js
	Example module to show how to include other JS files into you browserify build
*/

// dependencies for this module go here
var $ = require('traversty'),
	qwery = require('qwery');

	// d3 = require('d3');


//give us old IE selector support (<8)
$.setSelectorEngine(qwery);

var UI = {
	html: $('html')[0],
	body: $('body')[0],

	overlay: $('.overlay'),
	overlayBtn: $('.overlay .btn'),

	symbolList: $('.symbol-list-wrapper')[0],
	symbolListBtn: $('.btn-list')[0],

	scrollActive: false,

	supports : {
		transform3d: false
	},

	init : function () {
		// d3.selectAll(".symbol").style("color", function() {
  // 			return "hsl(" + Math.random() * 360 + ",100%,50%)";
		// });
		//

		this.browserSupportChecks();

		this.handleZooming();

		this.initOverlays();
		this.initInfoOverlay();
		this.symbolOverlay();

	},

	browserSupportChecks : function  () {

		if (this.html.classList.contains('csstransforms3d')) {
			this.supports.transform3d = true;
		}

	},

	initOverlays : function () {

		var index = 0,
			overlayNum = this.overlay.length;

		//loop through each overlay and attach listeners
		for (index; index < overlayNum; index++) {
			this.overlayBtn[index].addEventListener('click', function (e) {
				e.preventDefault();

				var context = this.getAttribute('data-close');
				$('.' + context)[0].classList.add('inactive');
				UI.scrollActive = true;

				//if the intro modal is closed, scroll to the top of the window
				if (context === 'overlay--intro') {
					window.scrollTo(0, 0);
				}
			});
		}

	},

	initInfoOverlay : function () {

		var footerLink = $('.page-footer-info')[0];

		footerLink.addEventListener('click', function (e) {
			e.preventDefault();

			UI.hideAllOverlays();
			$('.overlay--info')[0].classList.remove('inactive');

		});

	},

	hideAllOverlays : function () {

		var index = 0,
			overlayNum = this.overlay.length;

		//loop through each overlay and attach listeners
		for (index; index < overlayNum; index++) {
			this.overlay[index].classList.add('inactive');
		}

	},

	symbolOverlay : function () {

		this.symbolListBtn.addEventListener('click', function (e) {
			e.preventDefault();

			//only open if we are in 'open scrolling mode'
			UI.hideAllOverlays();
			UI.symbolList.classList.remove('inactive', 'hide');
			$('#scroll-proxy')[0].classList.add('inactive');
			window.scrollTo(0, 0);
			UI.scrollActive = false;
		});

		//close button for the symbol overlay
		$('.btn--close')[0].addEventListener('click', function (e) {
			e.preventDefault();

			UI.symbolList.classList.add('inactive');
			$('#scroll-proxy')[0].classList.remove('inactive');
			UI.scrollActive = true;
		});

	},


	updateSymbol : function (name, data) {

		// log(name, data);
		var symbolTotal = $('.symbol--' + name + ' .symbol-total');

		if (symbolTotal.length > 0) {
			var index = 0,
				symLength = symbolTotal.length;

			for (index; index < symLength; index++) {
				symbolTotal[index].innerHTML = this.numberWithCommas(data.total);
			}
		}

	},

	numberWithCommas : function(x) {
		return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	},


	handleZooming : function () {

		// only proceed if CSS transforms are supported
	// NEED TO FIX
		//if ( !Modernizr.csstransforms ) { return; }

		var zoomContent = $('.illust-container')[0];

		ZUI = new Zoomer(zoomContent);

		//make sure page is at the top when reloaded
		window.scrollTo(0, 0);

	//on page load calculate current position and scale to it
		// ZUI.recalculatePositions();

	}
};

// the constructor that will do all the work
function Zoomer( content ) {

	this.setLevels = function() {

		if (this.docWidth > 1500) {
			this.levels = 6.2;
			this.verticalTranslate = 3000;
		} else if (this.docWidth > 1350) {
			this.levels = 6;
			this.verticalTranslate = 2750;
		} else if (this.docWidth > 1250) {
			this.levels = 5.8;
			this.verticalTranslate = 2450;
		} else if (this.docWidth > 1150) {
			this.levels = 5.7;
			this.verticalTranslate = 2350;
		} else if (this.docWidth > 1050) {
			this.levels = 5.5;
			this.verticalTranslate = 2100;
		} else if (this.docWidth > 950) {
			this.levels = 5.35;
			this.verticalTranslate = 1900;
		} else if (this.docWidth > 850) {
			this.levels = 5.15;
			this.verticalTranslate = 1700;
		} else {
			this.levels = 4.9;
			this.verticalTranslate = 1520;
		}

	};

	// keep track of DOM
	this.content = content;

	this.header = $('.page-header')[0];
	this.body = $('body')[0];
	this.town = $('.illust-level--town')[0];
	this.townSymbols = $('.illust-level--symbolsTown')[0];
	this.house = $('.svg-house')[0];
	this.carollers = $('.svg-carollers')[0];
	this.star = $('.svg-star')[0];

	// position of vertical scroll
	this.scrolled = 0;

	var body = document.body,
		html = document.documentElement;

	// height of document
	this.docHeight = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight );
	this.docWidth = html.clientWidth;

	// zero-based number of sections
	this.setLevels();


	// bind Zoomer to scroll event
	window.addEventListener( 'scroll', this, false);
}

// enables constructor to be used within event listener
// like obj.addEventListener( eventName, this, false )
Zoomer.prototype.handleEvent = function( event ) {
	if ( this[event.type] ) {
		this[event.type](event);
	}
};

// triggered every time window scrolls
Zoomer.prototype.scroll = function( event ) {

	if (UI.scrollActive) {
		this.recalculatePositions();
	}

};

Zoomer.prototype.recalculatePositions = function () {

	//LETS HAVE SOME DEFAULTS HERE
	var INITIAL_TOWN_WIDTH = 350,
		INITIAL_TOWN_HEIGHT = 320,
		TARGET_TOWN_WIDTH = 2800,
		TARGET_TOWN_HEIGHT = 2560,

		TARGET_BG_ZSCALE = 200,

		OFFSET_MARGIN = 80,

		TARGET_VERTICAL_TRANSLATE = 2600;


	var supportPageOffset = window.pageXOffset !== undefined;
	var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");

	var yOffset = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;

	// normalize scroll value from 0 to 1
	this.scrolled = yOffset / ( this.docHeight - window.innerHeight );

	var transformValue,
		width,
		transformPrefix,
		townTransform,
		symboltransformValue;

	this.checkStates();

	var scrollFactor = (this.scrolled < 0.5 ? this.scrolled : 0.5);
	var scale = Math.pow( 3, scrollFactor * this.levels );
	var townHeight = Math.round(scale * INITIAL_TOWN_HEIGHT);
	var townWidth = Math.round(scale * INITIAL_TOWN_WIDTH);
	var townOffset = Math.round(scale * OFFSET_MARGIN) - OFFSET_MARGIN;

	//first half of app is the scale – this zooms into the house
	if (scrollFactor < 0.5) {

		var zScale = Math.round((scale * TARGET_BG_ZSCALE) - TARGET_BG_ZSCALE);

		var townYPos = Math.round(((townHeight / 2) + townOffset));

		//if we support translate3d
		if (UI.supports.transform3d) {
			transformValue = 'translate3d(0, 0, 0) scale(' + scale + ')';

			townTransform = 'translate3d(-50%, -' + townYPos + 'px, 0)';
			symboltransformValue = 'translate3d(-' + (townWidth / 2) + 'px, -' + townYPos + 'px, 0)' + ' scale(' + scale + ')';
		} else {
			transformValue = 'translate(0, 0) scale(' + scale + ')';

			townTransform = 'translate(-50%, -' + townYPos + 'px)';
			symboltransformValue = 'translate(-' + (townWidth / 2) + 'px, -' + townYPos + 'px)' + ' scale(' + scale + ')';
		}

	//the second half is the translate vertically
	} else {

		var percentageThroughSection = ((this.scrolled - 0.5) / 0.5); //get the percentage of the amount through the section (on a scale 0-1)
		var verticalTranslate = percentageThroughSection * this.verticalTranslate; //gets a scaled amount dependent on the percentage of the section scrolled through

		var townYPos = Math.round((townHeight / 2) + townOffset - verticalTranslate);

		//if we support translate3d
		if (UI.supports.transform3d) {
			transformValue = 'translate3d(0, 0, 0) scale(' + scale + ')';
			townTransform = 'translate3d(-50%, -' + townYPos + 'px, 0)';
		} else {
			transformValue = 'translate(0, 0) scale(' + scale + ')';
			townTransform = 'translate(-50%, -' + townYPos + 'px)';
		}

	}

	// SETTING OF OUR NEW VALUES

	//update width and height of town
	this.town.style.width = townWidth + 'px';
	this.town.style.height = townHeight + 'px';

	// //update the transformed value for the town
	this.town.style.WebkitTransform = townTransform;
	this.town.style.MozTransform = townTransform;
	this.town.style.msTransform = townTransform;
	this.town.style.transform = townTransform;

	// //update scale factor of the outside illustrations and text
	// if(navigator.userAgent.toLowerCase().indexOf('firefox') === -1) {
		this.content.style.WebkitTransform = transformValue;
		this.content.style.MozTransform = transformValue;
		this.content.style.msTransform = transformValue;
		this.content.style.transform = transformValue;
	// }

	// //town symbols scaling
	this.townSymbols.style.WebkitTransform = 'scale(' + scale + ')';
	this.townSymbols.style.MozTransform = 'scale(' + scale + ')';
	this.townSymbols.style.msTransform = 'scale(' + scale + ')';
	this.townSymbols.style.transform = 'scale(' + scale + ')';

};


Zoomer.prototype.checkStates = function () {

	if (this.scrolled > 0) {
		this.header.classList.add('scaled');
	} else {
		this.header.classList.remove('scaled');
	}

	//do a test whether to switch to night or not (after 0.25 scrolled)
	if (this.scrolled > 0.15) {
		this.body.classList.add('night');
	} else {
		this.body.classList.remove('night');
	}

	//test between state of movement
	if (this.scrolled < 0.5) {

		this.house.classList.remove('inactive'); //make house visible
		this.carollers.classList.remove('inactive'); //make carollers invisible
		this.star.classList.add('inactive'); //make carollers invisible
		this.townSymbols.querySelector('.symbols--inside').classList.add('inactive'); //make nativity symbols not visible
		this.townSymbols.querySelector('.symbols--outside').classList.remove('inactive'); //make nativity symbols not visible

	} else {

		this.house.classList.add('inactive'); //make house not visible
		this.carollers.classList.add('inactive'); //make carollers invisible
		this.star.classList.remove('inactive'); //make carollers invisible
		this.townSymbols.querySelector('.symbols--inside').classList.remove('inactive'); //make nativity symbols visible
		this.townSymbols.querySelector('.symbols--outside').classList.add('inactive'); //make nativity symbols not visible

	}

};




module.exports = UI;
},{"qwery":1,"traversty":2}],7:[function(require,module,exports){
/*	Author:
		TMW - (Author Name Here)
*/

// --------------------------------------------- //
// DEFINE GLOBAL LIBS                            //
// --------------------------------------------- //
// Uncomment the line below to expose jQuery as a global object to the usual places
// window.jQuery = window.$ = require('./libs/jquery/jquery-1.10.2.js');

// force compilation of global libs that don't return a value.
require("./helpers/log");
require("./helpers/shims");


//initialise KO object
var KO = window.KO = {};

KO.Sockets = require('./modules/sockets');
KO.UI = require('./modules/ui');

KO.Config = {

	init : function () {
		KO.UI.init();
		KO.Sockets.init();
	}
};


KO.Config.init();
},{"./helpers/log":3,"./helpers/shims":4,"./modules/sockets":5,"./modules/ui":6}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvYW5vbGFuMS9fcHJvamVjdHMvX2xhYnMvY2hyaXN0bWFzLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3F3ZXJ5L3F3ZXJ5LmpzIiwiL1VzZXJzL2Fub2xhbjEvX3Byb2plY3RzL19sYWJzL2NocmlzdG1hcy10cmFja2VyL25vZGVfbW9kdWxlcy90cmF2ZXJzdHkvdHJhdmVyc3R5LmpzIiwiL1VzZXJzL2Fub2xhbjEvX3Byb2plY3RzL19sYWJzL2NocmlzdG1hcy10cmFja2VyL3B1YmxpYy9qcy9oZWxwZXJzL2xvZy5qcyIsIi9Vc2Vycy9hbm9sYW4xL19wcm9qZWN0cy9fbGFicy9jaHJpc3RtYXMtdHJhY2tlci9wdWJsaWMvanMvaGVscGVycy9zaGltcy5qcyIsIi9Vc2Vycy9hbm9sYW4xL19wcm9qZWN0cy9fbGFicy9jaHJpc3RtYXMtdHJhY2tlci9wdWJsaWMvanMvbW9kdWxlcy9zb2NrZXRzLmpzIiwiL1VzZXJzL2Fub2xhbjEvX3Byb2plY3RzL19sYWJzL2NocmlzdG1hcy10cmFja2VyL3B1YmxpYy9qcy9tb2R1bGVzL3VpLmpzIiwiL1VzZXJzL2Fub2xhbjEvX3Byb2plY3RzL19sYWJzL2NocmlzdG1hcy10cmFja2VyL3B1YmxpYy9qcy9zY3JpcHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiFcbiAgKiBAcHJlc2VydmUgUXdlcnkgLSBBIEJsYXppbmcgRmFzdCBxdWVyeSBzZWxlY3RvciBlbmdpbmVcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL3F3ZXJ5XG4gICogY29weXJpZ2h0IER1c3RpbiBEaWF6IDIwMTJcbiAgKiBNSVQgTGljZW5zZVxuICAqL1xuXG4oZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSBjb250ZXh0W25hbWVdID0gZGVmaW5pdGlvbigpXG59KSgncXdlcnknLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudFxuICAgICwgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnRcbiAgICAsIGJ5Q2xhc3MgPSAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSdcbiAgICAsIGJ5VGFnID0gJ2dldEVsZW1lbnRzQnlUYWdOYW1lJ1xuICAgICwgcVNBID0gJ3F1ZXJ5U2VsZWN0b3JBbGwnXG4gICAgLCB1c2VOYXRpdmVRU0EgPSAndXNlTmF0aXZlUVNBJ1xuICAgICwgdGFnTmFtZSA9ICd0YWdOYW1lJ1xuICAgICwgbm9kZVR5cGUgPSAnbm9kZVR5cGUnXG4gICAgLCBzZWxlY3QgLy8gbWFpbiBzZWxlY3QoKSBtZXRob2QsIGFzc2lnbiBsYXRlclxuXG4gICAgLCBpZCA9IC8jKFtcXHdcXC1dKykvXG4gICAgLCBjbGFzID0gL1xcLltcXHdcXC1dKy9nXG4gICAgLCBpZE9ubHkgPSAvXiMoW1xcd1xcLV0rKSQvXG4gICAgLCBjbGFzc09ubHkgPSAvXlxcLihbXFx3XFwtXSspJC9cbiAgICAsIHRhZ09ubHkgPSAvXihbXFx3XFwtXSspJC9cbiAgICAsIHRhZ0FuZE9yQ2xhc3MgPSAvXihbXFx3XSspP1xcLihbXFx3XFwtXSspJC9cbiAgICAsIHNwbGl0dGFibGUgPSAvKF58LClcXHMqWz5+K10vXG4gICAgLCBub3JtYWxpenIgPSAvXlxccyt8XFxzKihbLFxcc1xcK1xcfj5dfCQpXFxzKi9nXG4gICAgLCBzcGxpdHRlcnMgPSAvW1xcc1xcPlxcK1xcfl0vXG4gICAgLCBzcGxpdHRlcnNNb3JlID0gLyg/IVtcXHNcXHdcXC1cXC9cXD9cXCZcXD1cXDpcXC5cXChcXClcXCEsQCMlPD5cXHtcXH1cXCRcXCpcXF4nXCJdKlxcXXxbXFxzXFx3XFwrXFwtXSpcXCkpL1xuICAgICwgc3BlY2lhbENoYXJzID0gLyhbLiorP1xcXj0hOiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nXG4gICAgLCBzaW1wbGUgPSAvXihcXCp8W2EtejAtOV0rKT8oPzooW1xcLlxcI10rW1xcd1xcLVxcLiNdKyk/KS9cbiAgICAsIGF0dHIgPSAvXFxbKFtcXHdcXC1dKykoPzooW1xcfFxcXlxcJFxcKlxcfl0/XFw9KVsnXCJdPyhbIFxcd1xcLVxcL1xcP1xcJlxcPVxcOlxcLlxcKFxcKVxcISxAIyU8Plxce1xcfVxcJFxcKlxcXl0rKVtcIiddPyk/XFxdL1xuICAgICwgcHNldWRvID0gLzooW1xcd1xcLV0rKShcXChbJ1wiXT8oW14oKV0rKVsnXCJdP1xcKSk/L1xuICAgICwgZWFzeSA9IG5ldyBSZWdFeHAoaWRPbmx5LnNvdXJjZSArICd8JyArIHRhZ09ubHkuc291cmNlICsgJ3wnICsgY2xhc3NPbmx5LnNvdXJjZSlcbiAgICAsIGRpdmlkZXJzID0gbmV3IFJlZ0V4cCgnKCcgKyBzcGxpdHRlcnMuc291cmNlICsgJyknICsgc3BsaXR0ZXJzTW9yZS5zb3VyY2UsICdnJylcbiAgICAsIHRva2VuaXpyID0gbmV3IFJlZ0V4cChzcGxpdHRlcnMuc291cmNlICsgc3BsaXR0ZXJzTW9yZS5zb3VyY2UpXG4gICAgLCBjaHVua2VyID0gbmV3IFJlZ0V4cChzaW1wbGUuc291cmNlICsgJygnICsgYXR0ci5zb3VyY2UgKyAnKT8nICsgJygnICsgcHNldWRvLnNvdXJjZSArICcpPycpXG5cbiAgdmFyIHdhbGtlciA9IHtcbiAgICAgICcgJzogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZSAhPT0gaHRtbCAmJiBub2RlLnBhcmVudE5vZGVcbiAgICAgIH1cbiAgICAsICc+JzogZnVuY3Rpb24gKG5vZGUsIGNvbnRlc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlID09IGNvbnRlc3RhbnQucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGVcbiAgICAgIH1cbiAgICAsICd+JzogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5wcmV2aW91c1NpYmxpbmdcbiAgICAgIH1cbiAgICAsICcrJzogZnVuY3Rpb24gKG5vZGUsIGNvbnRlc3RhbnQsIHAxLCBwMikge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gKHAxID0gcHJldmlvdXMobm9kZSkpICYmIChwMiA9IHByZXZpb3VzKGNvbnRlc3RhbnQpKSAmJiBwMSA9PSBwMiAmJiBwMVxuICAgICAgfVxuICAgIH1cblxuICBmdW5jdGlvbiBjYWNoZSgpIHtcbiAgICB0aGlzLmMgPSB7fVxuICB9XG4gIGNhY2hlLnByb3RvdHlwZSA9IHtcbiAgICBnOiBmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHRoaXMuY1trXSB8fCB1bmRlZmluZWRcbiAgICB9XG4gICwgczogZnVuY3Rpb24gKGssIHYsIHIpIHtcbiAgICAgIHYgPSByID8gbmV3IFJlZ0V4cCh2KSA6IHZcbiAgICAgIHJldHVybiAodGhpcy5jW2tdID0gdilcbiAgICB9XG4gIH1cblxuICB2YXIgY2xhc3NDYWNoZSA9IG5ldyBjYWNoZSgpXG4gICAgLCBjbGVhbkNhY2hlID0gbmV3IGNhY2hlKClcbiAgICAsIGF0dHJDYWNoZSA9IG5ldyBjYWNoZSgpXG4gICAgLCB0b2tlbkNhY2hlID0gbmV3IGNhY2hlKClcblxuICBmdW5jdGlvbiBjbGFzc1JlZ2V4KGMpIHtcbiAgICByZXR1cm4gY2xhc3NDYWNoZS5nKGMpIHx8IGNsYXNzQ2FjaGUucyhjLCAnKF58XFxcXHMrKScgKyBjICsgJyhcXFxccyt8JCknLCAxKVxuICB9XG5cbiAgLy8gbm90IHF1aXRlIGFzIGZhc3QgYXMgaW5saW5lIGxvb3BzIGluIG9sZGVyIGJyb3dzZXJzIHNvIGRvbid0IHVzZSBsaWJlcmFsbHlcbiAgZnVuY3Rpb24gZWFjaChhLCBmbikge1xuICAgIHZhciBpID0gMCwgbCA9IGEubGVuZ3RoXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIGZuKGFbaV0pXG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuKGFyKSB7XG4gICAgZm9yICh2YXIgciA9IFtdLCBpID0gMCwgbCA9IGFyLmxlbmd0aDsgaSA8IGw7ICsraSkgYXJyYXlMaWtlKGFyW2ldKSA/IChyID0gci5jb25jYXQoYXJbaV0pKSA6IChyW3IubGVuZ3RoXSA9IGFyW2ldKVxuICAgIHJldHVybiByXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheWlmeShhcikge1xuICAgIHZhciBpID0gMCwgbCA9IGFyLmxlbmd0aCwgciA9IFtdXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHJbaV0gPSBhcltpXVxuICAgIHJldHVybiByXG4gIH1cblxuICBmdW5jdGlvbiBwcmV2aW91cyhuKSB7XG4gICAgd2hpbGUgKG4gPSBuLnByZXZpb3VzU2libGluZykgaWYgKG5bbm9kZVR5cGVdID09IDEpIGJyZWFrO1xuICAgIHJldHVybiBuXG4gIH1cblxuICBmdW5jdGlvbiBxKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5Lm1hdGNoKGNodW5rZXIpXG4gIH1cblxuICAvLyBjYWxsZWQgdXNpbmcgYHRoaXNgIGFzIGVsZW1lbnQgYW5kIGFyZ3VtZW50cyBmcm9tIHJlZ2V4IGdyb3VwIHJlc3VsdHMuXG4gIC8vIGdpdmVuID0+IGRpdi5oZWxsb1t0aXRsZT1cIndvcmxkXCJdOmZvbygnYmFyJylcbiAgLy8gZGl2LmhlbGxvW3RpdGxlPVwid29ybGRcIl06Zm9vKCdiYXInKSwgZGl2LCAuaGVsbG8sIFt0aXRsZT1cIndvcmxkXCJdLCB0aXRsZSwgPSwgd29ybGQsIDpmb28oJ2JhcicpLCBmb28sICgnYmFyJyksIGJhcl1cbiAgZnVuY3Rpb24gaW50ZXJwcmV0KHdob2xlLCB0YWcsIGlkc0FuZENsYXNzZXMsIHdob2xlQXR0cmlidXRlLCBhdHRyaWJ1dGUsIHF1YWxpZmllciwgdmFsdWUsIHdob2xlUHNldWRvLCBwc2V1ZG8sIHdob2xlUHNldWRvVmFsLCBwc2V1ZG9WYWwpIHtcbiAgICB2YXIgaSwgbSwgaywgbywgY2xhc3Nlc1xuICAgIGlmICh0aGlzW25vZGVUeXBlXSAhPT0gMSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRhZyAmJiB0YWcgIT09ICcqJyAmJiB0aGlzW3RhZ05hbWVdICYmIHRoaXNbdGFnTmFtZV0udG9Mb3dlckNhc2UoKSAhPT0gdGFnKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoaWRzQW5kQ2xhc3NlcyAmJiAobSA9IGlkc0FuZENsYXNzZXMubWF0Y2goaWQpKSAmJiBtWzFdICE9PSB0aGlzLmlkKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoaWRzQW5kQ2xhc3NlcyAmJiAoY2xhc3NlcyA9IGlkc0FuZENsYXNzZXMubWF0Y2goY2xhcykpKSB7XG4gICAgICBmb3IgKGkgPSBjbGFzc2VzLmxlbmd0aDsgaS0tOykgaWYgKCFjbGFzc1JlZ2V4KGNsYXNzZXNbaV0uc2xpY2UoMSkpLnRlc3QodGhpcy5jbGFzc05hbWUpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHBzZXVkbyAmJiBxd2VyeS5wc2V1ZG9zW3BzZXVkb10gJiYgIXF3ZXJ5LnBzZXVkb3NbcHNldWRvXSh0aGlzLCBwc2V1ZG9WYWwpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAod2hvbGVBdHRyaWJ1dGUgJiYgIXZhbHVlKSB7IC8vIHNlbGVjdCBpcyBqdXN0IGZvciBleGlzdGFuY2Ugb2YgYXR0cmliXG4gICAgICBvID0gdGhpcy5hdHRyaWJ1dGVzXG4gICAgICBmb3IgKGsgaW4gbykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspICYmIChvW2tdLm5hbWUgfHwgaykgPT0gYXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2hvbGVBdHRyaWJ1dGUgJiYgIWNoZWNrQXR0cihxdWFsaWZpZXIsIGdldEF0dHIodGhpcywgYXR0cmlidXRlKSB8fCAnJywgdmFsdWUpKSB7XG4gICAgICAvLyBzZWxlY3QgaXMgZm9yIGF0dHJpYiBlcXVhbGl0eVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbihzKSB7XG4gICAgcmV0dXJuIGNsZWFuQ2FjaGUuZyhzKSB8fCBjbGVhbkNhY2hlLnMocywgcy5yZXBsYWNlKHNwZWNpYWxDaGFycywgJ1xcXFwkMScpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tBdHRyKHF1YWxpZnksIGFjdHVhbCwgdmFsKSB7XG4gICAgc3dpdGNoIChxdWFsaWZ5KSB7XG4gICAgY2FzZSAnPSc6XG4gICAgICByZXR1cm4gYWN0dWFsID09IHZhbFxuICAgIGNhc2UgJ149JzpcbiAgICAgIHJldHVybiBhY3R1YWwubWF0Y2goYXR0ckNhY2hlLmcoJ149JyArIHZhbCkgfHwgYXR0ckNhY2hlLnMoJ149JyArIHZhbCwgJ14nICsgY2xlYW4odmFsKSwgMSkpXG4gICAgY2FzZSAnJD0nOlxuICAgICAgcmV0dXJuIGFjdHVhbC5tYXRjaChhdHRyQ2FjaGUuZygnJD0nICsgdmFsKSB8fCBhdHRyQ2FjaGUucygnJD0nICsgdmFsLCBjbGVhbih2YWwpICsgJyQnLCAxKSlcbiAgICBjYXNlICcqPSc6XG4gICAgICByZXR1cm4gYWN0dWFsLm1hdGNoKGF0dHJDYWNoZS5nKHZhbCkgfHwgYXR0ckNhY2hlLnModmFsLCBjbGVhbih2YWwpLCAxKSlcbiAgICBjYXNlICd+PSc6XG4gICAgICByZXR1cm4gYWN0dWFsLm1hdGNoKGF0dHJDYWNoZS5nKCd+PScgKyB2YWwpIHx8IGF0dHJDYWNoZS5zKCd+PScgKyB2YWwsICcoPzpefFxcXFxzKyknICsgY2xlYW4odmFsKSArICcoPzpcXFxccyt8JCknLCAxKSlcbiAgICBjYXNlICd8PSc6XG4gICAgICByZXR1cm4gYWN0dWFsLm1hdGNoKGF0dHJDYWNoZS5nKCd8PScgKyB2YWwpIHx8IGF0dHJDYWNoZS5zKCd8PScgKyB2YWwsICdeJyArIGNsZWFuKHZhbCkgKyAnKC18JCknLCAxKSlcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIGdpdmVuIGEgc2VsZWN0b3IsIGZpcnN0IGNoZWNrIGZvciBzaW1wbGUgY2FzZXMgdGhlbiBjb2xsZWN0IGFsbCBiYXNlIGNhbmRpZGF0ZSBtYXRjaGVzIGFuZCBmaWx0ZXJcbiAgZnVuY3Rpb24gX3F3ZXJ5KHNlbGVjdG9yLCBfcm9vdCkge1xuICAgIHZhciByID0gW10sIHJldCA9IFtdLCBpLCBsLCBtLCB0b2tlbiwgdGFnLCBlbHMsIGludHIsIGl0ZW0sIHJvb3QgPSBfcm9vdFxuICAgICAgLCB0b2tlbnMgPSB0b2tlbkNhY2hlLmcoc2VsZWN0b3IpIHx8IHRva2VuQ2FjaGUucyhzZWxlY3Rvciwgc2VsZWN0b3Iuc3BsaXQodG9rZW5penIpKVxuICAgICAgLCBkaXZpZGVkVG9rZW5zID0gc2VsZWN0b3IubWF0Y2goZGl2aWRlcnMpXG5cbiAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHJldHVybiByXG5cbiAgICB0b2tlbiA9ICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMCkpLnBvcCgpIC8vIGNvcHkgY2FjaGVkIHRva2VucywgdGFrZSB0aGUgbGFzdCBvbmVcbiAgICBpZiAodG9rZW5zLmxlbmd0aCAmJiAobSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ubWF0Y2goaWRPbmx5KSkpIHJvb3QgPSBieUlkKF9yb290LCBtWzFdKVxuICAgIGlmICghcm9vdCkgcmV0dXJuIHJcblxuICAgIGludHIgPSBxKHRva2VuKVxuICAgIC8vIGNvbGxlY3QgYmFzZSBjYW5kaWRhdGVzIHRvIGZpbHRlclxuICAgIGVscyA9IHJvb3QgIT09IF9yb290ICYmIHJvb3Rbbm9kZVR5cGVdICE9PSA5ICYmIGRpdmlkZWRUb2tlbnMgJiYgL15bK35dJC8udGVzdChkaXZpZGVkVG9rZW5zW2RpdmlkZWRUb2tlbnMubGVuZ3RoIC0gMV0pID9cbiAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHdoaWxlIChyb290ID0gcm9vdC5uZXh0U2libGluZykge1xuICAgICAgICAgIHJvb3Rbbm9kZVR5cGVdID09IDEgJiYgKGludHJbMV0gPyBpbnRyWzFdID09IHJvb3RbdGFnTmFtZV0udG9Mb3dlckNhc2UoKSA6IDEpICYmIChyW3IubGVuZ3RoXSA9IHJvb3QpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJcbiAgICAgIH0oW10pIDpcbiAgICAgIHJvb3RbYnlUYWddKGludHJbMV0gfHwgJyonKVxuICAgIC8vIGZpbHRlciBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LW1vc3QgcGFydCBvZiB0aGUgc2VsZWN0b3JcbiAgICBmb3IgKGkgPSAwLCBsID0gZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGl0ZW0gPSBpbnRlcnByZXQuYXBwbHkoZWxzW2ldLCBpbnRyKSkgcltyLmxlbmd0aF0gPSBpdGVtXG4gICAgfVxuICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIHJcblxuICAgIC8vIGZpbHRlciBmdXJ0aGVyIGFjY29yZGluZyB0byB0aGUgcmVzdCBvZiB0aGUgc2VsZWN0b3IgKHRoZSBsZWZ0IHNpZGUpXG4gICAgZWFjaChyLCBmdW5jdGlvbiAoZSkgeyBpZiAoYW5jZXN0b3JNYXRjaChlLCB0b2tlbnMsIGRpdmlkZWRUb2tlbnMpKSByZXRbcmV0Lmxlbmd0aF0gPSBlIH0pXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29tcGFyZSBlbGVtZW50IHRvIGEgc2VsZWN0b3JcbiAgZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yLCByb290KSB7XG4gICAgaWYgKGlzTm9kZShzZWxlY3RvcikpIHJldHVybiBlbCA9PSBzZWxlY3RvclxuICAgIGlmIChhcnJheUxpa2Uoc2VsZWN0b3IpKSByZXR1cm4gISF+ZmxhdHRlbihzZWxlY3RvcikuaW5kZXhPZihlbCkgLy8gaWYgc2VsZWN0b3IgaXMgYW4gYXJyYXksIGlzIGVsIGEgbWVtYmVyP1xuXG4gICAgdmFyIHNlbGVjdG9ycyA9IHNlbGVjdG9yLnNwbGl0KCcsJyksIHRva2VucywgZGl2aWRlZFRva2Vuc1xuICAgIHdoaWxlIChzZWxlY3RvciA9IHNlbGVjdG9ycy5wb3AoKSkge1xuICAgICAgdG9rZW5zID0gdG9rZW5DYWNoZS5nKHNlbGVjdG9yKSB8fCB0b2tlbkNhY2hlLnMoc2VsZWN0b3IsIHNlbGVjdG9yLnNwbGl0KHRva2VuaXpyKSlcbiAgICAgIGRpdmlkZWRUb2tlbnMgPSBzZWxlY3Rvci5tYXRjaChkaXZpZGVycylcbiAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgwKSAvLyBjb3B5IGFycmF5XG4gICAgICBpZiAoaW50ZXJwcmV0LmFwcGx5KGVsLCBxKHRva2Vucy5wb3AoKSkpICYmICghdG9rZW5zLmxlbmd0aCB8fCBhbmNlc3Rvck1hdGNoKGVsLCB0b2tlbnMsIGRpdmlkZWRUb2tlbnMsIHJvb3QpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGdpdmVuIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSByaWdodC1tb3N0IHBhcnQgb2YgYSBzZWxlY3RvciwgZmlsdGVyIG91dCBhbnkgdGhhdCBkb24ndCBtYXRjaCB0aGUgcmVzdFxuICBmdW5jdGlvbiBhbmNlc3Rvck1hdGNoKGVsLCB0b2tlbnMsIGRpdmlkZWRUb2tlbnMsIHJvb3QpIHtcbiAgICB2YXIgY2FuZFxuICAgIC8vIHJlY3Vyc2l2ZWx5IHdvcmsgYmFja3dhcmRzIHRocm91Z2ggdGhlIHRva2VucyBhbmQgdXAgdGhlIGRvbSwgY292ZXJpbmcgYWxsIG9wdGlvbnNcbiAgICBmdW5jdGlvbiBjcmF3bChlLCBpLCBwKSB7XG4gICAgICB3aGlsZSAocCA9IHdhbGtlcltkaXZpZGVkVG9rZW5zW2ldXShwLCBlKSkge1xuICAgICAgICBpZiAoaXNOb2RlKHApICYmIChpbnRlcnByZXQuYXBwbHkocCwgcSh0b2tlbnNbaV0pKSkpIHtcbiAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgaWYgKGNhbmQgPSBjcmF3bChwLCBpIC0gMSwgcCkpIHJldHVybiBjYW5kXG4gICAgICAgICAgfSBlbHNlIHJldHVybiBwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChjYW5kID0gY3Jhd2woZWwsIHRva2Vucy5sZW5ndGggLSAxLCBlbCkpICYmICghcm9vdCB8fCBpc0FuY2VzdG9yKGNhbmQsIHJvb3QpKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKGVsLCB0KSB7XG4gICAgcmV0dXJuIGVsICYmIHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgKHQgPSBlbFtub2RlVHlwZV0pICYmICh0ID09IDEgfHwgdCA9PSA5KVxuICB9XG5cbiAgZnVuY3Rpb24gdW5pcShhcikge1xuICAgIHZhciBhID0gW10sIGksIGo7XG4gICAgbzpcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhLmxlbmd0aDsgKytqKSBpZiAoYVtqXSA9PSBhcltpXSkgY29udGludWUgb1xuICAgICAgYVthLmxlbmd0aF0gPSBhcltpXVxuICAgIH1cbiAgICByZXR1cm4gYVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlMaWtlKG8pIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBpc0Zpbml0ZShvLmxlbmd0aCkpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVSb290KHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpIHJldHVybiBkb2NcbiAgICBpZiAodHlwZW9mIHJvb3QgPT0gJ3N0cmluZycpIHJldHVybiBxd2VyeShyb290KVswXVxuICAgIGlmICghcm9vdFtub2RlVHlwZV0gJiYgYXJyYXlMaWtlKHJvb3QpKSByZXR1cm4gcm9vdFswXVxuICAgIHJldHVybiByb290XG4gIH1cblxuICBmdW5jdGlvbiBieUlkKHJvb3QsIGlkLCBlbCkge1xuICAgIC8vIGlmIGRvYywgcXVlcnkgb24gaXQsIGVsc2UgcXVlcnkgdGhlIHBhcmVudCBkb2Mgb3IgaWYgYSBkZXRhY2hlZCBmcmFnbWVudCByZXdyaXRlIHRoZSBxdWVyeSBhbmQgcnVuIG9uIHRoZSBmcmFnbWVudFxuICAgIHJldHVybiByb290W25vZGVUeXBlXSA9PT0gOSA/IHJvb3QuZ2V0RWxlbWVudEJ5SWQoaWQpIDpcbiAgICAgIHJvb3Qub3duZXJEb2N1bWVudCAmJlxuICAgICAgICAoKChlbCA9IHJvb3Qub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpICYmIGlzQW5jZXN0b3IoZWwsIHJvb3QpICYmIGVsKSB8fFxuICAgICAgICAgICghaXNBbmNlc3Rvcihyb290LCByb290Lm93bmVyRG9jdW1lbnQpICYmIHNlbGVjdCgnW2lkPVwiJyArIGlkICsgJ1wiXScsIHJvb3QpWzBdKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHF3ZXJ5KHNlbGVjdG9yLCBfcm9vdCkge1xuICAgIHZhciBtLCBlbCwgcm9vdCA9IG5vcm1hbGl6ZVJvb3QoX3Jvb3QpXG5cbiAgICAvLyBlYXN5LCBmYXN0IGNhc2VzIHRoYXQgd2UgY2FuIGRpc3BhdGNoIHdpdGggc2ltcGxlIERPTSBjYWxsc1xuICAgIGlmICghcm9vdCB8fCAhc2VsZWN0b3IpIHJldHVybiBbXVxuICAgIGlmIChzZWxlY3RvciA9PT0gd2luZG93IHx8IGlzTm9kZShzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiAhX3Jvb3QgfHwgKHNlbGVjdG9yICE9PSB3aW5kb3cgJiYgaXNOb2RlKHJvb3QpICYmIGlzQW5jZXN0b3Ioc2VsZWN0b3IsIHJvb3QpKSA/IFtzZWxlY3Rvcl0gOiBbXVxuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgJiYgYXJyYXlMaWtlKHNlbGVjdG9yKSkgcmV0dXJuIGZsYXR0ZW4oc2VsZWN0b3IpXG4gICAgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChlYXN5KSkge1xuICAgICAgaWYgKG1bMV0pIHJldHVybiAoZWwgPSBieUlkKHJvb3QsIG1bMV0pKSA/IFtlbF0gOiBbXVxuICAgICAgaWYgKG1bMl0pIHJldHVybiBhcnJheWlmeShyb290W2J5VGFnXShtWzJdKSlcbiAgICAgIGlmIChoYXNCeUNsYXNzICYmIG1bM10pIHJldHVybiBhcnJheWlmeShyb290W2J5Q2xhc3NdKG1bM10pKVxuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IsIHJvb3QpXG4gIH1cblxuICAvLyB3aGVyZSB0aGUgcm9vdCBpcyBub3QgZG9jdW1lbnQgYW5kIGEgcmVsYXRpb25zaGlwIHNlbGVjdG9yIGlzIGZpcnN0IHdlIGhhdmUgdG9cbiAgLy8gZG8gc29tZSBhd2t3YXJkIGFkanVzdG1lbnRzIHRvIGdldCBpdCB0byB3b3JrLCBldmVuIHdpdGggcVNBXG4gIGZ1bmN0aW9uIGNvbGxlY3RTZWxlY3Rvcihyb290LCBjb2xsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBvaWQsIG5pZFxuICAgICAgaWYgKHNwbGl0dGFibGUudGVzdChzKSkge1xuICAgICAgICBpZiAocm9vdFtub2RlVHlwZV0gIT09IDkpIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGVsIGhhcyBhbiBpZCwgcmV3cml0ZSB0aGUgcXVlcnksIHNldCByb290IHRvIGRvYyBhbmQgcnVuIGl0XG4gICAgICAgICAgaWYgKCEobmlkID0gb2lkID0gcm9vdC5nZXRBdHRyaWJ1dGUoJ2lkJykpKSByb290LnNldEF0dHJpYnV0ZSgnaWQnLCBuaWQgPSAnX19xd2VyeW1ldXBzY290dHknKVxuICAgICAgICAgIHMgPSAnW2lkPVwiJyArIG5pZCArICdcIl0nICsgcyAvLyBhdm9pZCBieUlkIGFuZCBhbGxvdyB1cyB0byBtYXRjaCBjb250ZXh0IGVsZW1lbnRcbiAgICAgICAgICBjb2xsZWN0b3Iocm9vdC5wYXJlbnROb2RlIHx8IHJvb3QsIHMsIHRydWUpXG4gICAgICAgICAgb2lkIHx8IHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcy5sZW5ndGggJiYgY29sbGVjdG9yKHJvb3QsIHMsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpc0FuY2VzdG9yID0gJ2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uJyBpbiBodG1sID9cbiAgICBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gKGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIDE2KSA9PSAxNlxuICAgIH0gOiAnY29udGFpbnMnIGluIGh0bWwgP1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lcltub2RlVHlwZV0gPT09IDkgfHwgY29udGFpbmVyID09IHdpbmRvdyA/IGh0bWwgOiBjb250YWluZXJcbiAgICAgIHJldHVybiBjb250YWluZXIgIT09IGVsZW1lbnQgJiYgY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpXG4gICAgfSA6XG4gICAgZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHJldHVybiAxXG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgLCBnZXRBdHRyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZGV0ZWN0IGJ1Z2d5IElFIHNyYy9ocmVmIGdldEF0dHJpYnV0ZSgpIGNhbGxcbiAgICAgIHZhciBlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgcmV0dXJuICgoZS5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIiN4XCI+eDwvYT4nKSAmJiBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCdocmVmJykgIT0gJyN4JykgP1xuICAgICAgICBmdW5jdGlvbiAoZSwgYSkge1xuICAgICAgICAgIHJldHVybiBhID09PSAnY2xhc3MnID8gZS5jbGFzc05hbWUgOiAoYSA9PT0gJ2hyZWYnIHx8IGEgPT09ICdzcmMnKSA/XG4gICAgICAgICAgICBlLmdldEF0dHJpYnV0ZShhLCAyKSA6IGUuZ2V0QXR0cmlidXRlKGEpXG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiAoZSwgYSkgeyByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoYSkgfVxuICAgIH0oKVxuICAsIGhhc0J5Q2xhc3MgPSAhIWRvY1tieUNsYXNzXVxuICAgIC8vIGhhcyBuYXRpdmUgcVNBIHN1cHBvcnRcbiAgLCBoYXNRU0EgPSBkb2MucXVlcnlTZWxlY3RvciAmJiBkb2NbcVNBXVxuICAgIC8vIHVzZSBuYXRpdmUgcVNBXG4gICwgc2VsZWN0UVNBID0gZnVuY3Rpb24gKHNlbGVjdG9yLCByb290KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNzLCBlXG4gICAgICB0cnkge1xuICAgICAgICBpZiAocm9vdFtub2RlVHlwZV0gPT09IDkgfHwgIXNwbGl0dGFibGUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAvLyBtb3N0IHdvcmsgaXMgZG9uZSByaWdodCBoZXJlLCBkZWZlciB0byBxU0FcbiAgICAgICAgICByZXR1cm4gYXJyYXlpZnkocm9vdFtxU0FdKHNlbGVjdG9yKSlcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0aGUgc2VydmljZXMgb2YgYGNvbGxlY3RTZWxlY3RvcigpYFxuICAgICAgICBlYWNoKHNzID0gc2VsZWN0b3Iuc3BsaXQoJywnKSwgY29sbGVjdFNlbGVjdG9yKHJvb3QsIGZ1bmN0aW9uIChjdHgsIHMpIHtcbiAgICAgICAgICBlID0gY3R4W3FTQV0ocylcbiAgICAgICAgICBpZiAoZS5sZW5ndGggPT0gMSkgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gZS5pdGVtKDApXG4gICAgICAgICAgZWxzZSBpZiAoZS5sZW5ndGgpIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYXJyYXlpZnkoZSkpXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm4gc3MubGVuZ3RoID4gMSAmJiByZXN1bHQubGVuZ3RoID4gMSA/IHVuaXEocmVzdWx0KSA6IHJlc3VsdFxuICAgICAgfSBjYXRjaCAoZXgpIHsgfVxuICAgICAgcmV0dXJuIHNlbGVjdE5vbk5hdGl2ZShzZWxlY3Rvciwgcm9vdClcbiAgICB9XG4gICAgLy8gbm8gbmF0aXZlIHNlbGVjdG9yIHN1cHBvcnRcbiAgLCBzZWxlY3ROb25OYXRpdmUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHJvb3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaXRlbXMsIG0sIGksIGwsIHIsIHNzXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2Uobm9ybWFsaXpyLCAnJDEnKVxuICAgICAgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaCh0YWdBbmRPckNsYXNzKSkge1xuICAgICAgICByID0gY2xhc3NSZWdleChtWzJdKVxuICAgICAgICBpdGVtcyA9IHJvb3RbYnlUYWddKG1bMV0gfHwgJyonKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHIudGVzdChpdGVtc1tpXS5jbGFzc05hbWUpKSByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtc1tpXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIC8vIG1vcmUgY29tcGxleCBzZWxlY3RvciwgZ2V0IGBfcXdlcnkoKWAgdG8gZG8gdGhlIHdvcmsgZm9yIHVzXG4gICAgICBlYWNoKHNzID0gc2VsZWN0b3Iuc3BsaXQoJywnKSwgY29sbGVjdFNlbGVjdG9yKHJvb3QsIGZ1bmN0aW9uIChjdHgsIHMsIHJld3JpdGUpIHtcbiAgICAgICAgciA9IF9xd2VyeShzLCBjdHgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSByLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChjdHhbbm9kZVR5cGVdID09PSA5IHx8IHJld3JpdGUgfHwgaXNBbmNlc3RvcihyW2ldLCByb290KSkgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcltpXVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICAgIHJldHVybiBzcy5sZW5ndGggPiAxICYmIHJlc3VsdC5sZW5ndGggPiAxID8gdW5pcShyZXN1bHQpIDogcmVzdWx0XG4gICAgfVxuICAsIGNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAvLyBjb25maWdOYXRpdmVRU0E6IHVzZSBmdWxseS1pbnRlcm5hbCBzZWxlY3RvciBvciBuYXRpdmUgcVNBIHdoZXJlIHByZXNlbnRcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1t1c2VOYXRpdmVRU0FdICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgc2VsZWN0ID0gIW9wdGlvbnNbdXNlTmF0aXZlUVNBXSA/IHNlbGVjdE5vbk5hdGl2ZSA6IGhhc1FTQSA/IHNlbGVjdFFTQSA6IHNlbGVjdE5vbk5hdGl2ZVxuICAgIH1cblxuICBjb25maWd1cmUoeyB1c2VOYXRpdmVRU0E6IHRydWUgfSlcblxuICBxd2VyeS5jb25maWd1cmUgPSBjb25maWd1cmVcbiAgcXdlcnkudW5pcSA9IHVuaXFcbiAgcXdlcnkuaXMgPSBpc1xuICBxd2VyeS5wc2V1ZG9zID0ge31cblxuICByZXR1cm4gcXdlcnlcbn0pO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAqIFRyYXZlcnN0eTogQSBET00gY29sbGVjdGlvbiBtYW5hZ2VtZW50IGFuZCB0cmF2ZXJzYWwgdXRpbGl0eVxuICAqIChjKSBSb2QgVmFnZyAoQHJ2YWdnKSAyMDEyXG4gICogaHR0cHM6Ly9naXRodWIuY29tL3J2YWdnL3RyYXZlcnN0eVxuICAqIExpY2Vuc2U6IE1JVFxuICAqL1xuXG4oZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGRlZmluaXRpb24pIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2VcbiAgICBjb250ZXh0W25hbWVdID0gZGVmaW5pdGlvbigpXG59KSgndHJhdmVyc3R5JywgdGhpcywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjb250ZXh0ID0gdGhpc1xuICAgICwgb2xkID0gY29udGV4dC50cmF2ZXJzdHlcbiAgICAsIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxuICAgICwgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnRcbiAgICAsIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICwgQXAgPSBBcnJheS5wcm90b3R5cGVcbiAgICAsIHNsaWNlID0gQXAuc2xpY2VcbiAgICAgIC8vIGZlYXR1cmUgdGVzdCB0byBmaW5kIG5hdGl2ZSBtYXRjaGVzU2VsZWN0b3IoKVxuICAgICwgbWF0Y2hlc1NlbGVjdG9yID0gKGZ1bmN0aW9uIChlbCwgcGZ4LCBuYW1lLCBpLCBtcykge1xuICAgICAgICB3aGlsZSAoaSA8IHBmeC5sZW5ndGgpXG4gICAgICAgICAgaWYgKGVsW21zID0gcGZ4W2krK10gKyBuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiBtc1xuICAgICAgfShodG1sLCBbICdtc00nLCAnd2Via2l0TScsICdtb3pNJywgJ29NJywgJ20nIF0sICdhdGNoZXNTZWxlY3RvcicsIDApKVxuXG4gICAgLCBLZmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAsIGlzTnVtYmVyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE51bWJlcl0nXG4gICAgICB9XG5cbiAgICAsIGlzU3RyaW5nID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IFN0cmluZ10nXG4gICAgICB9XG5cbiAgICAsIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICAgICAgfVxuXG4gICAgLCBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvID09PSB2b2lkIDBcbiAgICAgIH1cblxuICAgICwgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gJiYgby5ub2RlVHlwZSA9PT0gMVxuICAgICAgfVxuXG4gICAgICAvLyBmaWd1cmUgb3V0IHdoaWNoIGFyZ3VtZW50LCBpZiBhbnksIGlzIG91ciAnaW5kZXgnXG4gICAgLCBnZXRJbmRleCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKHNlbGVjdG9yKSAmJiAhaXNOdW1iZXIoaW5kZXgpID8gMCA6XG4gICAgICAgICAgaXNOdW1iZXIoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBpc051bWJlcihpbmRleCkgPyBpbmRleCA6IG51bGxcbiAgICAgIH1cblxuICAgICAgLy8gZmlndXJlIG91dCB3aGljaCBhcmd1bWVudCwgaWYgYW55LCBpcyBvdXIgJ3NlbGVjdG9yJ1xuICAgICwgZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogJyonXG4gICAgICB9XG5cbiAgICAsIG5hdGl2ZVNlbGVjdG9yRmluZCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgZWwpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIDApXG4gICAgICB9XG5cbiAgICAsIG5hdGl2ZVNlbGVjdG9yTWF0Y2hlcyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yID09PSAnKicgfHwgZWxbbWF0Y2hlc1NlbGVjdG9yXShzZWxlY3RvcilcbiAgICAgIH1cblxuICAgICwgc2VsZWN0b3JGaW5kID0gbmF0aXZlU2VsZWN0b3JGaW5kXG5cbiAgICAsIHNlbGVjdG9yTWF0Y2hlcyA9IG5hdGl2ZVNlbGVjdG9yTWF0Y2hlc1xuXG4gICAgICAvLyB1c2VkIGluIHRoZSBjYXNlIHdoZXJlIG91ciBzZWxlY3RvciBlbmdpbmUgZG9lcyBvdXQtb2Ytb3JkZXIgZWxlbWVudCByZXR1cm5zIGZvclxuICAgICAgLy8gZ3JvdXBlZCBzZWxlY3RvcnMsIGUuZy4gJy5jbGFzcywgdGFnJywgd2UgbmVlZCBvdXIgZWxlbWVudHMgaW4gZG9jdW1lbnQtb3JkZXJcbiAgICAgIC8vIHNvIHdlIGRvIGl0IG91cnNlbHZlcyBpZiBuZWVkIGJlXG4gICAgLCBjcmVhdGVVbm9yZGVyZWRFbmdpbmVTZWxlY3RvckZpbmQgPSBmdW5jdGlvbihlbmdpbmVTZWxlY3QsIHNlbGVjdG9yTWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yLCBlbCkge1xuICAgICAgICAgIGlmICgvLC8udGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSwgaSA9IC0xLCBlbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgZWxzLmxlbmd0aClcbiAgICAgICAgICAgICAgaWYgKGlzRWxlbWVudChlbHNbaV0pICYmIHNlbGVjdG9yTWF0Y2hlcyhzZWxlY3RvciwgZWxzW2ldKSlcbiAgICAgICAgICAgICAgICByZXQucHVzaChlbHNbaV0pXG4gICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbmdpbmVTZWxlY3Qoc2VsZWN0b3IsIGVsKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlzICdlbGVtZW50JyB1bmRlcm5lYXRoICdjb250YWluZXInIHNvbWV3aGVyZVxuICAgICwgaXNBbmNlc3RvciA9ICdjb21wYXJlRG9jdW1lbnRQb3NpdGlvbicgaW4gaHRtbFxuICAgICAgICA/IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgMTYpID09IDE2XG4gICAgICAgICAgfVxuICAgICAgICA6ICdjb250YWlucycgaW4gaHRtbFxuICAgICAgICAgID8gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDkgfHwgY29udGFpbmVyID09IHdpbmRvdyA/IGh0bWwgOiBjb250YWluZXJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lciAhPT0gZWxlbWVudCAmJiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIpIHsgLy8gb2xkIHNtZWxseSBicm93c2VyXG4gICAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBvbmx5IHVuaXF1ZSBlbGVtZW50c1xuICAgICwgdW5pcXVlID0gZnVuY3Rpb24gKGFyKSB7XG4gICAgICAgIHZhciBhID0gW10sIGkgPSAtMSwgaiwgaGFzXG4gICAgICAgIHdoaWxlICgrK2kgPCBhci5sZW5ndGgpIHtcbiAgICAgICAgICBqID0gLTFcbiAgICAgICAgICBoYXMgPSBmYWxzZVxuICAgICAgICAgIHdoaWxlICgrK2ogPCBhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGFbal0gPT09IGFyW2ldKSB7XG4gICAgICAgICAgICAgIGhhcyA9IHRydWVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFoYXMpXG4gICAgICAgICAgICBhLnB1c2goYXJbaV0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggZWxlbWVudCBvZiAnZWxzJyBleGVjdXRlICdmbicgdG8gZ2V0IGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIGNvbGxlY3RcbiAgICAsIGNvbGxlY3QgPSBmdW5jdGlvbiAoZWxzLCBmbikge1xuICAgICAgICB2YXIgcmV0ID0gW10sIHJlcywgaSA9IDAsIGosIGwgPSBlbHMubGVuZ3RoLCBsMlxuICAgICAgICB3aGlsZSAoaSA8IGwpIHtcbiAgICAgICAgICBqID0gMFxuICAgICAgICAgIGwyID0gKHJlcyA9IGZuKGVsc1tpXSwgaSsrKSkubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKGogPCBsMilcbiAgICAgICAgICAgIHJldC5wdXNoKHJlc1tqKytdKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIH1cblxuICAgICAvLyBnZW5lcmljIERPTSBuYXZpZ2F0b3IgdG8gbW92ZSBtdWx0aXBsZSBlbGVtZW50cyBhcm91bmQgdGhlIERPTVxuICAgLCBtb3ZlID0gZnVuY3Rpb24gKGVscywgbWV0aG9kLCBzZWxlY3RvciwgaW5kZXgsIGZpbHRlckZuKSB7XG4gICAgICAgIGluZGV4ID0gZ2V0SW5kZXgoc2VsZWN0b3IsIGluZGV4KVxuICAgICAgICBzZWxlY3RvciA9IGdldFNlbGVjdG9yKHNlbGVjdG9yKVxuICAgICAgICByZXR1cm4gY29sbGVjdChlbHNcbiAgICAgICAgICAsIGZ1bmN0aW9uIChlbCwgZWxpbmQpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSBpbmRleCB8fCAwLCByZXQgPSBbXVxuICAgICAgICAgICAgICBpZiAoIWZpbHRlckZuKVxuICAgICAgICAgICAgICAgIGVsID0gZWxbbWV0aG9kXVxuICAgICAgICAgICAgICB3aGlsZSAoZWwgJiYgKGluZGV4ID09PSBudWxsIHx8IGkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbm9uLWVsZW1lbnRzLCBvbmx5IGNvbnNpZGVyIHNlbGVjdG9yLW1hdGNoaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGJvdGggdGhlIGluZGV4IGFuZCBuby1pbmRleCAoc2VsZWN0b3Itb25seSkgY2FzZXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50KGVsKVxuICAgICAgICAgICAgICAgICAgICAmJiAoIWZpbHRlckZuIHx8IGZpbHRlckZuID09PSB0cnVlIHx8IGZpbHRlckZuKGVsLCBlbGluZCkpXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGVjdG9yTWF0Y2hlcyhzZWxlY3RvciwgZWwpXG4gICAgICAgICAgICAgICAgICAgICYmIChpbmRleCA9PT0gbnVsbCB8fCBpLS0gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbmNhdCB2cyBwdXNoIGlzIHRvIG1ha2Ugc3VyZSB3ZSBhZGQgZWxlbWVudHMgdG8gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgICAgICAgLy8gaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRvaW5nIGEgcHJldmlvdXMoc2VsZWN0b3IpIGFuZCB1cChzZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgIGluZGV4ID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgJiYgbWV0aG9kICE9ICduZXh0U2libGluZydcbiAgICAgICAgICAgICAgICAgICAgICAmJiBtZXRob2QgIT0gJ3BhcmVudE5vZGUnXG4gICAgICAgICAgICAgICAgICAgID8gcmV0LnVuc2hpZnQoZWwpXG4gICAgICAgICAgICAgICAgICAgIDogcmV0LnB1c2goZWwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsID0gZWxbbWV0aG9kXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBnaXZlbiBhbiBpbmRleCAmIGxlbmd0aCwgcmV0dXJuIGEgJ2ZpeGVkJyBpbmRleCwgZml4ZXMgbm9uLW51bWJlcnMgJiBuZWF0aXZlIGluZGV4ZXNcbiAgICAsIGVxSW5kZXggPSBmdW5jdGlvbiAobGVuZ3RoLCBpbmRleCwgZGVmKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGggKyBpbmRleFxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gIWluZGV4ICYmIGluZGV4ICE9PSAwID8gZGVmIDogaW5kZXhcbiAgICAgIH1cblxuICAgICAgLy8gY29sbGVjdCBlbGVtZW50cyBvZiBhbiBhcnJheSB0aGF0IG1hdGNoIGEgZmlsdGVyIGZ1bmN0aW9uXG4gICAgLCBmaWx0ZXIgPSBmdW5jdGlvbiAoZWxzLCBmbikge1xuICAgICAgICB2YXIgYXJyID0gW10sIGkgPSAwLCBsID0gZWxzLmxlbmd0aFxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBpZiAoZm4oZWxzW2ldLCBpKSlcbiAgICAgICAgICAgIGFyci5wdXNoKGVsc1tpXSlcbiAgICAgICAgcmV0dXJuIGFyclxuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYSBmaWx0ZXIgZnVuY3Rpb24sIGZvciB1c2UgYnkgZmlsdGVyKCksIGlzKCkgJiBub3QoKVxuICAgICAgLy8gYWxsb3dzIHRoZSBhcmd1bWVudCB0byBiZSBhbiBlbGVtZW50LCBhIGZ1bmN0aW9uIG9yIGEgc2VsZWN0b3JcbiAgICAsIGZpbHRlckZuID0gZnVuY3Rpb24gKHNsZm4pIHtcbiAgICAgICAgdmFyIHRvXG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQoc2xmbilcbiAgICAgICAgICA/IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwgPT09IHNsZm4gfVxuICAgICAgICAgIDogKHRvID0gdHlwZW9mIHNsZm4pID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGVsLCBpKSB7IHJldHVybiBzbGZuLmNhbGwoZWwsIGkpIH1cbiAgICAgICAgICAgIDogdG8gPT0gJ3N0cmluZycgJiYgc2xmbi5sZW5ndGhcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHNlbGVjdG9yTWF0Y2hlcyhzbGZuLCBlbCkgfVxuICAgICAgICAgICAgICA6IEtmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBmbiA9ICFmblxuICAgICwgaW52ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICFmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICwgdHJhdmVyc3R5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVChlbHMpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICAgICAgICBpZiAoZWxzKSB7XG4gICAgICAgICAgICBlbHMgPSB1bmlxdWUoIWVscy5ub2RlVHlwZSAmJiAhaXNVbmRlZmluZWQoZWxzLmxlbmd0aCkgPyBlbHMgOiBbIGVscyBdKVxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aCA9IGVscy5sZW5ndGhcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgIHRoaXNbaV0gPSBlbHNbaV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBULnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uIChzZWxlY3RvciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBnZXRJbmRleChzZWxlY3RvciwgaW5kZXgpXG4gICAgICAgICAgICAgIHNlbGVjdG9yID0gZ2V0U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkoY29sbGVjdCh0aGlzXG4gICAgICAgICAgICAgICAgLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzZWxlY3RvckZpbmQoc2VsZWN0b3IsIGVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IG51bGwgPyBmIDogKFsgZltpbmRleF0gXSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCB1cDogZnVuY3Rpb24gKHNlbGVjdG9yLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc3R5KG1vdmUodGhpcywgJ3BhcmVudE5vZGUnLCBzZWxlY3RvciwgaW5kZXgpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCBwYXJlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBULnByb3RvdHlwZS51cC5hcHBseSh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzIDogWyAnKicgXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICwgY2xvc2VzdDogZnVuY3Rpb24gKHNlbGVjdG9yLCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyonXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkoW10pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTnVtYmVyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkobW92ZSh0aGlzLCAncGFyZW50Tm9kZScsIHNlbGVjdG9yLCBpbmRleCwgdHJ1ZSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAsIHByZXZpb3VzOiBmdW5jdGlvbiAoc2VsZWN0b3IsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkobW92ZSh0aGlzLCAncHJldmlvdXNTaWJsaW5nJywgc2VsZWN0b3IsIGluZGV4KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICwgbmV4dDogZnVuY3Rpb24gKHNlbGVjdG9yLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc3R5KG1vdmUodGhpcywgJ25leHRTaWJsaW5nJywgc2VsZWN0b3IsIGluZGV4KSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICwgc2libGluZ3M6IGZ1bmN0aW9uIChzZWxlY3RvciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgICAgICAgLCBhcnIgPSBzbGljZS5jYWxsKHRoaXMsIDApXG4gICAgICAgICAgICAgICAgLCBpID0gMCwgbCA9IGFyci5sZW5ndGhcblxuICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGFycltpXS5wYXJlbnROb2RlLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzRWxlbWVudChhcnJbaV0pKVxuICAgICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2ldLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2VsZWN0b3IpKVxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyonXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnN0eShtb3ZlKGFyciwgJ25leHRTaWJsaW5nJywgc2VsZWN0b3IgfHwgJyonLCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAsIGZ1bmN0aW9uIChlbCwgaSkgeyByZXR1cm4gZWwgIT09IHNlbGZbaV0gfSAvLyBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAsIGNoaWxkcmVuOiBmdW5jdGlvbiAoc2VsZWN0b3IsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkobW92ZShULnByb3RvdHlwZS5kb3duLmNhbGwodGhpcyksICduZXh0U2libGluZycsIHNlbGVjdG9yIHx8ICcqJywgaW5kZXgsIHRydWUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gVC5wcm90b3R5cGUuZXEuY2FsbCh0aGlzLCAwKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBULnByb3RvdHlwZS5lcS5jYWxsKHRoaXMsIC0xKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCBlcTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzdHkodGhpcy5nZXQoaW5kZXgpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLCBnZXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc1tlcUluZGV4KHRoaXMubGVuZ3RoLCBpbmRleCwgMCldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGEgY3JhenkgbWFuIHdyb3RlIHRoaXMsIGRvbid0IHRyeSB0byB1bmRlcnN0YW5kIGl0LCBzZWUgdGhlIHRlc3RzXG4gICAgICAgICAgLCBzbGljZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBlbmQsIGwgPSB0aGlzLmxlbmd0aCwgYXJyID0gW11cbiAgICAgICAgICAgICAgc3RhcnQgPSBlcUluZGV4KGwsIE1hdGgubWF4KC10aGlzLmxlbmd0aCwgc3RhcnQpLCAwKVxuICAgICAgICAgICAgICBlID0gZXFJbmRleChlbmQgPCAwID8gbCA6IGwgKyAxLCBlbmQsIGwpXG4gICAgICAgICAgICAgIGVuZCA9IGUgPT09IG51bGwgfHwgZSA+IGwgPyBlbmQgPCAwID8gMCA6IGwgOiBlXG4gICAgICAgICAgICAgIHdoaWxlIChzdGFydCAhPT0gbnVsbCAmJiBzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzW3N0YXJ0KytdKVxuICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc3R5KGFycilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICwgZmlsdGVyOiBmdW5jdGlvbiAoc2xmbikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc3R5KGZpbHRlcih0aGlzLCBmaWx0ZXJGbihzbGZuKSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAsIG5vdDogZnVuY3Rpb24gKHNsZm4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnN0eShmaWx0ZXIodGhpcywgaW52KGZpbHRlckZuKHNsZm4pKSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNpbWlsYXIgdG8gZmlsdGVyKCkgYnV0IGNhcmVzIGFib3V0IGRlc2NlbmRlbnQgZWxlbWVudHNcbiAgICAgICAgICAsIGhhczogZnVuY3Rpb24gKHNsZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnN0eShmaWx0ZXIoXG4gICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgLCBpc0VsZW1lbnQoc2xlbClcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGlzQW5jZXN0b3Ioc2xlbCwgZWwpIH1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2xlbCA9PSAnc3RyaW5nJyAmJiBzbGVsLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBzZWxlY3RvckZpbmQoc2xlbCwgZWwpLmxlbmd0aCB9IC8vVE9ETzogcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICAgICAgICA6IEtmYWxzZVxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGZpbHRlcigpIGJ1dCByZXR1cm4gYSBib29sZWFuIHNvIHF1aWNrLXJldHVybiBhZnRlciBmaXJzdCBzdWNjZXNzZnVsIGZpbmRcbiAgICAgICAgICAsIGlzOiBmdW5jdGlvbiAoc2xmbikge1xuICAgICAgICAgICAgICB2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgICAgICwgZm4gPSBmaWx0ZXJGbihzbGZuKVxuICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoZm4odGhpc1tpXSwgaSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICwgdG9BcnJheTogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXAuc2xpY2UuY2FsbCh0aGlzKSB9XG5cbiAgICAgICAgICAsIHNpemU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGVuZ3RoIH1cblxuICAgICAgICAgICwgZWFjaDogZnVuY3Rpb24gKGZuLCBjdHgpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHggfHwgdGhpc1tpXSwgdGhpc1tpXSwgaSwgdGhpcylcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcXVhY2sgbGlrZSBhIGR1Y2sgKEFycmF5KVxuICAgICAgICAgICwgcHVzaDogQXAucHVzaFxuICAgICAgICAgICwgc29ydDogQXAuc29ydFxuICAgICAgICAgICwgc3BsaWNlOiBBcC5zcGxpY2VcbiAgICAgICAgfVxuXG4gICAgICAgIFQucHJvdG90eXBlLnByZXYgPSBULnByb3RvdHlwZS5wcmV2aW91c1xuXG4gICAgICAgIGZ1bmN0aW9uIHQoZWxzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUKGlzU3RyaW5nKGVscykgPyBzZWxlY3RvckZpbmQoZWxzLCBkb2MpIDogZWxzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXh0ZW5kIHRyYXZlcnN0eSBmdW5jdGlvbmFsaXR5IHdpdGggY3VzdG9tIG1ldGhvZHNcbiAgICAgICAgdC5hdWcgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICAgIHZhciBrZXksIG1ldGhvZFxuICAgICAgICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZHNba2V5XVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgVC5wcm90b3R5cGVba2V5XSA9IG1ldGhvZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdC5zZXRTZWxlY3RvckVuZ2luZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgLy8gZmVhdHVyZSB0ZXN0aW5nIHRoZSBzZWxlY3RvciBlbmdpbmUgbGlrZSBhIGJvc3NcbiAgICAgICAgICB2YXIgc3MsIHIsIGEsIF9zZWxlY3Rvck1hdGNoZXMsIF9zZWxlY3RvckZpbmRcbiAgICAgICAgICAgICwgZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgICwgc2VsZWN0ID0gcy5zZWxlY3QgfHwgcy5zZWwgfHwgc1xuXG4gICAgICAgICAgZS5pbm5lckhUTUwgPSAnPGEvPjxpLz48Yi8+J1xuICAgICAgICAgIGEgPSBlLmZpcnN0Q2hpbGRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gWU8hIEkgSEVBUkQgWU9VIExJS0VEIE5FU1RFRCBURVJOQVJZIE9QRVJBVE9SUyBTTyBJIENPT0tFRCBTT01FIFVQIEZPUiBZT1UhXG4gICAgICAgICAgICAvLyAob25lIGRheSBJIG1pZ2h0IGxvb3AgdGhpcy4uLilcblxuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGhvdyB3ZSBkbyBhIG1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgX3NlbGVjdG9yTWF0Y2hlcyA9IGlzRnVuY3Rpb24ocy5tYXRjaGluZylcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoc2VsZWN0b3IsIGVsKSB7IHJldHVybiBzLm1hdGNoaW5nKFtlbF0sIHNlbGVjdG9yKS5sZW5ndGggPiAwIH1cbiAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHMuaXMpXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoc2VsZWN0b3IsIGVsKSB7IHJldHVybiBzLmlzKGVsLCBzZWxlY3RvcikgfVxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbihzLm1hdGNoZXNTZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHNlbGVjdG9yLCBlbCkgeyByZXR1cm4gcy5tYXRjaGVzU2VsZWN0b3IoZWwsIHNlbGVjdG9yKSB9XG4gICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ocy5tYXRjaClcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoc2VsZWN0b3IsIGVsKSB7IHJldHVybiBzLm1hdGNoKGVsLCBzZWxlY3RvcikgfVxuICAgICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ocy5tYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHNlbGVjdG9yLCBlbCkgeyByZXR1cm4gcy5tYXRjaGVzKGVsLCBzZWxlY3RvcikgfVxuICAgICAgICAgICAgICAgICAgICAgIDogbnVsbFxuXG4gICAgICAgICAgICBpZiAoIV9zZWxlY3Rvck1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgLy8gcGVyaGFwcyBpdCdzIGFuIHNlbGVjdG9yKHgpLmlzKHkpIHR5cGUgc2VsZWN0b3I/XG4gICAgICAgICAgICAgIHNzID0gcygnYScsIGUpXG4gICAgICAgICAgICAgIF9zZWxlY3Rvck1hdGNoZXMgPSBpc0Z1bmN0aW9uKHNzLl9pcylcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChzZWxlY3RvciwgZWwpIHsgcmV0dXJuIHMoZWwpLl9pcyhzZWxlY3RvcikgfSAvLyBvcmlnaW5hbCAuaXMoKSwgcmVwbGFjZWQgYnkgRW5kZXIgYnJpZGdlXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHNzLm1hdGNoaW5nKVxuICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoc2VsZWN0b3IsIGVsKSB7IHJldHVybiBzKGVsKS5tYXRjaGluZyhzZWxlY3RvcikubGVuZ3RoID4gMCB9XG4gICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24oc3MuaXMpICYmICFzcy5pcy5fX2lnbm9yZVxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChzZWxlY3RvciwgZWwpIHsgcmV0dXJuIHMoZWwpLmlzKHNlbGVjdG9yKSB9XG4gICAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHNzLm1hdGNoZXNTZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHNlbGVjdG9yLCBlbCkgeyByZXR1cm4gcyhlbCkubWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24oc3MubWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKHNlbGVjdG9yLCBlbCkgeyByZXR1cm4gcyhlbCkubWF0Y2goc2VsZWN0b3IpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHNzLm1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoc2VsZWN0b3IsIGVsKSB7IHJldHVybiBzKGVsKS5tYXRjaGVzKHNlbGVjdG9yKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX3NlbGVjdG9yTWF0Y2hlcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYXZlcnN0eTogY291bGRuXFwndCBmaW5kIHNlbGVjdG9yIGVuZ2luZVxcJ3MgYG1hdGNoZXNTZWxlY3RvcmAnKVxuXG4gICAgICAgICAgICAvLyB2ZXJpZnkgdGhhdCB3ZSBoYXZlIGEgd29ya2luZyBgbWF0Y2hlc1NlbGVjdG9yYFxuICAgICAgICAgICAgaWYgKF9zZWxlY3Rvck1hdGNoZXMoJ3gseScsIGUpIHx8ICFfc2VsZWN0b3JNYXRjaGVzKCdhLHAnLCBlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYXZlcnN0eTogY291bGRuXFwndCBtYWtlIHNlbGVjdG9yIGVuZ2luZVxcJ3MgYG1hdGNoZXNTZWxlY3RvcmAgd29yaycpXG5cbiAgICAgICAgICAgIC8vIGJhc2ljIHNlbGVjdFxuICAgICAgICAgICAgaWYgKChyID0gc2VsZWN0KCdiLGEnLCBlKSkubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYXZlcnN0eTogZG9uXFwndCBrbm93IGhvdyB0byB1c2UgdGhpcyBzZWxlY3RvciBlbmdpbmUnKVxuXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHNlbGVjdG9yIGVuZ2luZSBoYXMgZ2l2ZW4gdXMgdGhlIHJlc3VsdHMgaW4gZG9jdW1lbnQtb3JkZXJcbiAgICAgICAgICAgIC8vIGFuZCBpZiBub3QsIHdvcmsgYXJvdW5kIGl0XG4gICAgICAgICAgICBfc2VsZWN0b3JGaW5kID0gclswXSA9PT0gYSA/IHNlbGVjdCA6IGNyZWF0ZVVub3JkZXJlZEVuZ2luZVNlbGVjdG9yRmluZChzZWxlY3QsIF9zZWxlY3Rvck1hdGNoZXMpXG5cbiAgICAgICAgICAgIC8vIGhhdmUgd2UgZG9uZSBlbm91Z2ggdG8gZ2V0IGEgd29ya2luZyBgc2VsZWN0b3JGaW5kYD9cbiAgICAgICAgICAgIGlmICgociA9IF9zZWxlY3RvckZpbmQoJ2IsYScsIGUpKS5sZW5ndGggIT09IDIgfHwgclswXSAhPT0gYSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmF2ZXJzdHk6IGNvdWxkblxcJ3QgbWFrZSBzZWxlY3RvciBlbmdpbmUgd29yaycpXG5cbiAgICAgICAgICAgIHNlbGVjdG9yTWF0Y2hlcyA9IF9zZWxlY3Rvck1hdGNoZXNcbiAgICAgICAgICAgIHNlbGVjdG9yRmluZCA9IF9zZWxlY3RvckZpbmRcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhyb3cgaXNTdHJpbmcoZXgpXG4gICAgICAgICAgICAgID8gZXhcbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IoJ1RyYXZlcnN0eTogZXJyb3Igd2hpbGUgZmlndXJpbmcgb3V0IGhvdyB0aGUgc2VsZWN0b3IgZW5naW5lIHdvcmtzOiAnICsgKGV4Lm1lc3NhZ2UgfHwgZXgpKVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBlID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH1cblxuICAgICAgICB0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGV4dC50cmF2ZXJzdHkgPSBvbGRcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRcbiAgICAgIH0oKSlcbiBcbiAgcmV0dXJuIHRyYXZlcnN0eVxufSk7IiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgIExvZy5qcyAtIExpZ2h0d2VpZ2h0IHdyYXBwZXIgZm9yIGNvbnNvbGUubG9nXG5cbiAgIFVzYWdlOiBsb2coJ2luc2lkZSBjb29sRnVuYycsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAqIHBhdWxpcmlzaC5jb20vMjAwOS9sb2ctYS1saWdodHdlaWdodC13cmFwcGVyLWZvci1jb25zb2xlbG9nL1xuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbndpbmRvdy5sb2cgPSBmdW5jdGlvbiBmKCkge1xuXHRsb2cuaGlzdG9yeSA9IGxvZy5oaXN0b3J5IHx8IFtdO1xuXHRsb2cuaGlzdG9yeS5wdXNoKGFyZ3VtZW50cyk7XG5cdGlmICh0aGlzLmNvbnNvbGUpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdG5ld2Fycjtcblx0XHR0cnkge1xuXHRcdFx0YXJncy5jYWxsZWUgPSBmLmNhbGxlcjtcblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdG5ld2FyciA9IFtdLnNsaWNlLmNhbGwoYXJncyk7XG5cdFx0aWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ29iamVjdCcpICB7XG5cdFx0XHRsb2cuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgbmV3YXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbmV3YXJyKTtcblx0XHR9XG5cdH1cbn07XG4iLCIvKiEgXG5JbmNsdWRlZCBzaGltczogQXJyYXkuZm9yRWFjaCxBcnJheS5maWx0ZXIsQXJyYXkubWFwLEZ1bmN0aW9uLmJpbmQsRXZlbnRMaXN0ZW5lcixFbGVtZW50LmNsYXNzTGlzdFxuKi9cblxuLypcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCgpXG4qL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB2YXIgbiwgcjtcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIiB0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIHZhciBpID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBvID0gaS5sZW5ndGggPj4+IDA7XG4gICAgICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIC8vIFNlZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS4xMVxuICAgICAgICBpZiAodHlwZW9mIHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0ICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgICAgICByID0gMDtcbiAgICAgICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgICAgIHdoaWxlIChyIDwgbykge1xuICAgICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcbiAgICAgICAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgICBpZiAociBpbiBpKSB7XG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgICAgIGEgPSBpW3JdO1xuICAgICAgICAgICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG4gICAgICAgICAgICAgICAgdC5jYWxsKG4sIGEsIHIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgcisrO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyKClcbiovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24odCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHZhciBlID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbiA9IGUubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAodHlwZW9mIHQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBuOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChvIGluIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGVbb107XG4gICAgICAgICAgICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgT2JqZWN0LmRlZmluZVByb3BlcnR5IGF0XG4gICAgICAgICAgICAgICAgLy8gICAgICAgdGhlIG5leHQgaW5kZXgsIGFzIHB1c2ggY2FuIGJlIGFmZmVjdGVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gICAgICAgcHJvcGVydGllcyBvbiBPYmplY3QucHJvdG90eXBlIGFuZCBBcnJheS5wcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgLy8gICAgICAgQnV0IHRoYXQgbWV0aG9kJ3MgbmV3LCBhbmQgY29sbGlzaW9ucyBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyAgICAgICByYXJlLCBzbyB1c2UgdGhlIG1vcmUtY29tcGF0aWJsZSBhbHRlcm5hdGl2ZS5cbiAgICAgICAgICAgICAgICBpZiAodC5jYWxsKGksIGEsIG8sIGUpKSByLnB1c2goYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbn1cblxuLypcbiAgIEFycmF5IG1hcCBwYXRjaFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbmlmICghKFwibWFwXCIgaW4gQXJyYXkucHJvdG90eXBlKSkge1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGggPj4+IDAsIHIgPSBBcnJheShuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICByW2ldID0gdC5jYWxsKGUsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG59XG5cbi8qXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQoKVxuKi9cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgbiA9IHRoaXMsIHIgPSBmdW5jdGlvbigpIHt9LCBpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbi5hcHBseSh0aGlzIGluc3RhbmNlb2YgciAmJiB0ID8gdGhpcyA6IHQsIGUuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgci5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgaS5wcm90b3R5cGUgPSBuZXcgcigpO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9O1xufVxuXG4vLyBFdmVudExpc3RlbmVyIHwgTUlUL0dQTDIgfCBodHRwczovL2dpdGh1Yi5jb20vam9uYXRoYW50bmVhbC9FdmVudExpc3RlbmVyXG50aGlzLkVsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoRXZlbnQgJiYgIUVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgJiYgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gdCh0LCBlKSB7XG4gICAgICAgIFdpbmRvdy5wcm90b3R5cGVbdF0gPSBIVE1MRG9jdW1lbnQucHJvdG90eXBlW3RdID0gRWxlbWVudC5wcm90b3R5cGVbdF0gPSBlO1xuICAgIH1cbiAgICAvLyBhZGRcbiAgICB0KFwiYWRkRXZlbnRMaXN0ZW5lclwiLCBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcywgciA9IG4uYWRkRXZlbnRMaXN0ZW5lci5saXN0ZW5lcnMgPSBuLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzIHx8IHt9LCBpID0gclt0XSA9IHJbdF0gfHwgW107XG4gICAgICAgIC8vIGlmIG5vIGV2ZW50cyBleGlzdCwgYXR0YWNoIHRoZSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWkubGVuZ3RoKSB7XG4gICAgICAgICAgICBuLmF0dGFjaEV2ZW50KFwib25cIiArIHQsIGkuZXZlbnQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBuLmRvY3VtZW50ICYmIG4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG4uZG9jdW1lbnRFbGVtZW50IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBwb2x5ZmlsbCB3M2MgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgICAgIHQuY3VycmVudFRhcmdldCA9IG47XG4gICAgICAgICAgICAgICAgdC5wYWdlWCA9IHQuY2xpZW50WCArIGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB0LnBhZ2VZID0gdC5jbGllbnRZICsgZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0LnJlbGF0ZWRUYXJnZXQgPSB0LmZyb21FbGVtZW50IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0LnRhcmdldCA9IHQuc3JjRWxlbWVudCB8fCBuO1xuICAgICAgICAgICAgICAgIHQudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGNhY2hlZCBsaXN0IG9mIHRoZSBtYXN0ZXIgZXZlbnRzIGxpc3QgKHRvIHByb3RlY3QgdGhpcyBsb29wIGZyb20gYnJlYWtpbmcgd2hlbiBhbiBldmVudCBpcyByZW1vdmVkKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBvID0gW10uY29uY2F0KGkpLCBhLCBzID0gdHJ1ZTsgcyAmJiAoYSA9IG9bcl0pOyArK3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBjYWNoZWQgZXZlbnQgc3RpbGwgZXhpc3RzIGluIHRoZSBtYXN0ZXIgZXZlbnRzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIGM7IGMgPSBpW2xdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbGwobiwgdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGV2ZW50IHRvIHRoZSBtYXN0ZXIgZXZlbnQgbGlzdFxuICAgICAgICBpLnB1c2goZSk7XG4gICAgfSk7XG4gICAgLy8gcmVtb3ZlXG4gICAgdChcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgZnVuY3Rpb24odCwgZSkge1xuICAgICAgICB2YXIgbiA9IHRoaXMsIHIgPSBuLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzID0gbi5hZGRFdmVudExpc3RlbmVyLmxpc3RlbmVycyB8fCB7fSwgaSA9IHJbdF0gPSByW3RdIHx8IFtdO1xuICAgICAgICAvLyByZW1vdmUgdGhlIG5ld2VzdCBtYXRjaGluZyBldmVudCBmcm9tIHRoZSBtYXN0ZXIgZXZlbnQgbGlzdFxuICAgICAgICBmb3IgKHZhciBvID0gaS5sZW5ndGggLSAxLCBhOyBhID0gaVtvXTsgLS1vKSB7XG4gICAgICAgICAgICBpZiAoYSA9PSBlKSB7XG4gICAgICAgICAgICAgICAgaS5zcGxpY2UobywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm8gZXZlbnRzIGV4aXN0LCBkZXRhY2ggdGhlIGxpc3RlbmVyXG4gICAgICAgIGlmICghaS5sZW5ndGggJiYgaS5ldmVudCkge1xuICAgICAgICAgICAgbi5kZXRhY2hFdmVudChcIm9uXCIgKyB0LCBpLmV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGRpc3BhdGNoXG4gICAgdChcImRpc3BhdGNoRXZlbnRcIiwgZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsIG4gPSB0LnR5cGUsIHIgPSBlLmFkZEV2ZW50TGlzdGVuZXIubGlzdGVuZXJzID0gZS5hZGRFdmVudExpc3RlbmVyLmxpc3RlbmVycyB8fCB7fSwgaSA9IHJbbl0gPSByW25dIHx8IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGUuZmlyZUV2ZW50KFwib25cIiArIG4sIHQpO1xuICAgICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgICAgICBpZiAoaS5ldmVudCkge1xuICAgICAgICAgICAgICAgIGkuZXZlbnQodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDdXN0b21FdmVudFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3cucHJvdG90eXBlLCBcIkN1c3RvbUV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlKG4sIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHQuZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSwgbztcbiAgICAgICAgICAgICAgICBpLnR5cGUgPSBuO1xuICAgICAgICAgICAgICAgIGZvciAobyBpbiByKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvID09IFwiY2FuY2VsYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLnJldHVyblZhbHVlID0gIXIuY2FuY2VsYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvID09IFwiYnViYmxlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmNhbmNlbEJ1YmJsZSA9ICFyLmJ1YmJsZXM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobyA9PSBcImRldGFpbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmRldGFpbCA9IHIuZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHJlYWR5XG4gICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgIGlmIChlLmludGVydmFsICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGUuaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGUuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJET01Db250ZW50TG9hZGVkXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZSwgMSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGUpO1xufSgpO1xuXG4hdGhpcy5DdXN0b21FdmVudCAmJiBmdW5jdGlvbigpIHtcbiAgICAvLyBDdXN0b21FdmVudCBmb3IgYnJvd3NlcnMgd2hpY2ggZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCB0aGUgQ29uc3RydWN0b3IgbWV0aG9kXG4gICAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gdChlLCBuKSB7XG4gICAgICAgIHZhciByO1xuICAgICAgICBuID0gbiB8fCB7XG4gICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgci5pbml0Q3VzdG9tRXZlbnQoZSwgbi5idWJibGVzLCBuLmNhbmNlbGFibGUsIG4uZGV0YWlsKTtcbiAgICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnQgQ3VzdG9tRXZlbnQgYXQgYWxsLCB3ZSB1c2UgYSByZWd1bGFyIGV2ZW50IGluc3RlYWRcbiAgICAgICAgICAgIHIgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgICAgICAgci5pbml0RXZlbnQoZSwgbi5idWJibGVzLCBuLmNhbmNlbGFibGUpO1xuICAgICAgICAgICAgci5kZXRhaWwgPSBuLmRldGFpbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xufSgpO1xuXG4vKlxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXG4gKiAyMDE0LTAxLTMxXG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogUHVibGljIERvbWFpbi5cbiAqIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cbiAqL1xuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9jbGFzc0xpc3QuanMqL1xuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkpIHtcbiAgICAoZnVuY3Rpb24odCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKCEoXCJFbGVtZW50XCIgaW4gdCkpIHJldHVybjtcbiAgICAgICAgdmFyIGUgPSBcImNsYXNzTGlzdFwiLCBuID0gXCJwcm90b3R5cGVcIiwgciA9IHQuRWxlbWVudFtuXSwgaSA9IE9iamVjdCwgbyA9IFN0cmluZ1tuXS50cmltIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgIH0sIGEgPSBBcnJheVtuXS5pbmRleE9mIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gMCwgbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7ZSA8IG47IGUrKykge1xuICAgICAgICAgICAgICAgIGlmIChlIGluIHRoaXMgJiYgdGhpc1tlXSA9PT0gdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sIHMgPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0O1xuICAgICAgICAgICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3RdO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZTtcbiAgICAgICAgfSwgbCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIGlmIChlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHMoXCJTWU5UQVhfRVJSXCIsIFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXHMvLnRlc3QoZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcyhcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiLCBcIlN0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLmNhbGwodCwgZSk7XG4gICAgICAgIH0sIGMgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IG8uY2FsbCh0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLCBuID0gZSA/IGUuc3BsaXQoL1xccysvKSA6IFtdLCByID0gMCwgaSA9IG4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7ciA8IGk7IHIrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChuW3JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHUgPSBjW25dID0gW10sIGYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYyh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTW9zdCBET01FeGNlcHRpb24gaW1wbGVtZW50YXRpb25zIGRvbid0IGFsbG93IGNhbGxpbmcgRE9NRXhjZXB0aW9uJ3MgdG9TdHJpbmcoKVxuICAgICAgICAvLyBvbiBub24tRE9NRXhjZXB0aW9ucy4gRXJyb3IncyB0b1N0cmluZygpIGlzIHN1ZmZpY2llbnQgaGVyZS5cbiAgICAgICAgc1tuXSA9IEVycm9yW25dO1xuICAgICAgICB1Lml0ZW0gPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t0XSB8fCBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB1LmNvbnRhaW5zID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdCArPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIGwodGhpcywgdCkgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICB1LmFkZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcmd1bWVudHMsIGUgPSAwLCBuID0gdC5sZW5ndGgsIHIsIGkgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByID0gdFtlXSArIFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGwodGhpcywgcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoKytlIDwgbik7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1LnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBhcmd1bWVudHMsIGUgPSAwLCBuID0gdC5sZW5ndGgsIHIsIGkgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByID0gdFtlXSArIFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBsKHRoaXMsIHIpO1xuICAgICAgICAgICAgICAgIGlmIChvICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGljZShvLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoKytlIDwgbik7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1LnRvZ2dsZSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgIHQgKz0gXCJcIjtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5jb250YWlucyh0KSwgciA9IG4gPyBlICE9PSB0cnVlICYmIFwicmVtb3ZlXCIgOiBlICE9PSBmYWxzZSAmJiBcImFkZFwiO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3JdKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFuO1xuICAgICAgICB9O1xuICAgICAgICB1LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGkuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgIGdldDogZixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaS5kZWZpbmVQcm9wZXJ0eShyLCBlLCBwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcbiAgICAgICAgICAgICAgICBpZiAoaC5udW1iZXIgPT09IC0yMTQ2ODIzMjUyKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpLmRlZmluZVByb3BlcnR5KHIsIGUsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpW25dLl9fZGVmaW5lR2V0dGVyX18pIHtcbiAgICAgICAgICAgIHIuX19kZWZpbmVHZXR0ZXJfXyhlLCBmKTtcbiAgICAgICAgfVxuICAgIH0pKHNlbGYpO1xufSIsIi8qXG5cdHNvY2tldHMuanNcbiovXG5cbi8vIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBtb2R1bGUgZ28gaGVyZVxudmFyIFVJID0gcmVxdWlyZSgnLi91aScpO1xuXG52YXIgU29ja2V0cyA9IHtcblx0c29ja2V0IDogbnVsbCxcblxuXHRpbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMubWFrZVNvY2tldENvbm5lY3Rpb24oKTtcblxuXHRcdHRoaXMuTGlzdGVuZXJzLnNldHVwKCk7XG5cdH0sXG5cblx0bWFrZVNvY2tldENvbm5lY3Rpb24gOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY29ubmVjdGlvblVSTCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcblxuXHRcdHRoaXMuc29ja2V0ID0gaW8uY29ubmVjdChjb25uZWN0aW9uVVJMKTtcblxuXHR9LFxuXG5cdExpc3RlbmVycyA6IHtcblxuXHRcdHNldHVwIDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRTb2NrZXRzLnNvY2tldC5vbigndHdlZXQnLCB0aGlzLm9uVHdlZXRSZWNlaXZlZCk7XG5cblx0XHR9LFxuXG5cdFx0b25Ud2VldFJlY2VpdmVkIDogZnVuY3Rpb24gKHN5bWJvbE9iaikge1xuXG5cdFx0XHRVSS51cGRhdGVTeW1ib2woc3ltYm9sT2JqLmtleSwgc3ltYm9sT2JqLnN5bWJvbCk7XG5cblx0XHR9XG5cblx0fVxuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0czsiLCIvKlxuXHRVSS5qc1xuXHRFeGFtcGxlIG1vZHVsZSB0byBzaG93IGhvdyB0byBpbmNsdWRlIG90aGVyIEpTIGZpbGVzIGludG8geW91IGJyb3dzZXJpZnkgYnVpbGRcbiovXG5cbi8vIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBtb2R1bGUgZ28gaGVyZVxudmFyICQgPSByZXF1aXJlKCd0cmF2ZXJzdHknKSxcblx0cXdlcnkgPSByZXF1aXJlKCdxd2VyeScpO1xuXG5cdC8vIGQzID0gcmVxdWlyZSgnZDMnKTtcblxuXG4vL2dpdmUgdXMgb2xkIElFIHNlbGVjdG9yIHN1cHBvcnQgKDw4KVxuJC5zZXRTZWxlY3RvckVuZ2luZShxd2VyeSk7XG5cbnZhciBVSSA9IHtcblx0aHRtbDogJCgnaHRtbCcpWzBdLFxuXHRib2R5OiAkKCdib2R5JylbMF0sXG5cblx0b3ZlcmxheTogJCgnLm92ZXJsYXknKSxcblx0b3ZlcmxheUJ0bjogJCgnLm92ZXJsYXkgLmJ0bicpLFxuXG5cdHN5bWJvbExpc3Q6ICQoJy5zeW1ib2wtbGlzdC13cmFwcGVyJylbMF0sXG5cdHN5bWJvbExpc3RCdG46ICQoJy5idG4tbGlzdCcpWzBdLFxuXG5cdHNjcm9sbEFjdGl2ZTogZmFsc2UsXG5cblx0c3VwcG9ydHMgOiB7XG5cdFx0dHJhbnNmb3JtM2Q6IGZhbHNlXG5cdH0sXG5cblx0aW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkMy5zZWxlY3RBbGwoXCIuc3ltYm9sXCIpLnN0eWxlKFwiY29sb3JcIiwgZnVuY3Rpb24oKSB7XG4gIC8vIFx0XHRcdHJldHVybiBcImhzbChcIiArIE1hdGgucmFuZG9tKCkgKiAzNjAgKyBcIiwxMDAlLDUwJSlcIjtcblx0XHQvLyB9KTtcblx0XHQvL1xuXG5cdFx0dGhpcy5icm93c2VyU3VwcG9ydENoZWNrcygpO1xuXG5cdFx0dGhpcy5oYW5kbGVab29taW5nKCk7XG5cblx0XHR0aGlzLmluaXRPdmVybGF5cygpO1xuXHRcdHRoaXMuaW5pdEluZm9PdmVybGF5KCk7XG5cdFx0dGhpcy5zeW1ib2xPdmVybGF5KCk7XG5cblx0fSxcblxuXHRicm93c2VyU3VwcG9ydENoZWNrcyA6IGZ1bmN0aW9uICAoKSB7XG5cblx0XHRpZiAodGhpcy5odG1sLmNsYXNzTGlzdC5jb250YWlucygnY3NzdHJhbnNmb3JtczNkJykpIHtcblx0XHRcdHRoaXMuc3VwcG9ydHMudHJhbnNmb3JtM2QgPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdGluaXRPdmVybGF5cyA6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpbmRleCA9IDAsXG5cdFx0XHRvdmVybGF5TnVtID0gdGhpcy5vdmVybGF5Lmxlbmd0aDtcblxuXHRcdC8vbG9vcCB0aHJvdWdoIGVhY2ggb3ZlcmxheSBhbmQgYXR0YWNoIGxpc3RlbmVyc1xuXHRcdGZvciAoaW5kZXg7IGluZGV4IDwgb3ZlcmxheU51bTsgaW5kZXgrKykge1xuXHRcdFx0dGhpcy5vdmVybGF5QnRuW2luZGV4XS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHR2YXIgY29udGV4dCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWNsb3NlJyk7XG5cdFx0XHRcdCQoJy4nICsgY29udGV4dClbMF0uY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKTtcblx0XHRcdFx0VUkuc2Nyb2xsQWN0aXZlID0gdHJ1ZTtcblxuXHRcdFx0XHQvL2lmIHRoZSBpbnRybyBtb2RhbCBpcyBjbG9zZWQsIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSB3aW5kb3dcblx0XHRcdFx0aWYgKGNvbnRleHQgPT09ICdvdmVybGF5LS1pbnRybycpIHtcblx0XHRcdFx0XHR3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9LFxuXG5cdGluaXRJbmZvT3ZlcmxheSA6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmb290ZXJMaW5rID0gJCgnLnBhZ2UtZm9vdGVyLWluZm8nKVswXTtcblxuXHRcdGZvb3RlckxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRVSS5oaWRlQWxsT3ZlcmxheXMoKTtcblx0XHRcdCQoJy5vdmVybGF5LS1pbmZvJylbMF0uY2xhc3NMaXN0LnJlbW92ZSgnaW5hY3RpdmUnKTtcblxuXHRcdH0pO1xuXG5cdH0sXG5cblx0aGlkZUFsbE92ZXJsYXlzIDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdG92ZXJsYXlOdW0gPSB0aGlzLm92ZXJsYXkubGVuZ3RoO1xuXG5cdFx0Ly9sb29wIHRocm91Z2ggZWFjaCBvdmVybGF5IGFuZCBhdHRhY2ggbGlzdGVuZXJzXG5cdFx0Zm9yIChpbmRleDsgaW5kZXggPCBvdmVybGF5TnVtOyBpbmRleCsrKSB7XG5cdFx0XHR0aGlzLm92ZXJsYXlbaW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlJyk7XG5cdFx0fVxuXG5cdH0sXG5cblx0c3ltYm9sT3ZlcmxheSA6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuc3ltYm9sTGlzdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdC8vb25seSBvcGVuIGlmIHdlIGFyZSBpbiAnb3BlbiBzY3JvbGxpbmcgbW9kZSdcblx0XHRcdFVJLmhpZGVBbGxPdmVybGF5cygpO1xuXHRcdFx0VUkuc3ltYm9sTGlzdC5jbGFzc0xpc3QucmVtb3ZlKCdpbmFjdGl2ZScsICdoaWRlJyk7XG5cdFx0XHQkKCcjc2Nyb2xsLXByb3h5JylbMF0uY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKTtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcblx0XHRcdFVJLnNjcm9sbEFjdGl2ZSA9IGZhbHNlO1xuXHRcdH0pO1xuXG5cdFx0Ly9jbG9zZSBidXR0b24gZm9yIHRoZSBzeW1ib2wgb3ZlcmxheVxuXHRcdCQoJy5idG4tLWNsb3NlJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRVSS5zeW1ib2xMaXN0LmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlJyk7XG5cdFx0XHQkKCcjc2Nyb2xsLXByb3h5JylbMF0uY2xhc3NMaXN0LnJlbW92ZSgnaW5hY3RpdmUnKTtcblx0XHRcdFVJLnNjcm9sbEFjdGl2ZSA9IHRydWU7XG5cdFx0fSk7XG5cblx0fSxcblxuXG5cdHVwZGF0ZVN5bWJvbCA6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG5cblx0XHQvLyBsb2cobmFtZSwgZGF0YSk7XG5cdFx0dmFyIHN5bWJvbFRvdGFsID0gJCgnLnN5bWJvbC0tJyArIG5hbWUgKyAnIC5zeW1ib2wtdG90YWwnKTtcblxuXHRcdGlmIChzeW1ib2xUb3RhbC5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRzeW1MZW5ndGggPSBzeW1ib2xUb3RhbC5sZW5ndGg7XG5cblx0XHRcdGZvciAoaW5kZXg7IGluZGV4IDwgc3ltTGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdHN5bWJvbFRvdGFsW2luZGV4XS5pbm5lckhUTUwgPSB0aGlzLm51bWJlcldpdGhDb21tYXMoZGF0YS50b3RhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0sXG5cblx0bnVtYmVyV2l0aENvbW1hcyA6IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geC50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcblx0fSxcblxuXG5cdGhhbmRsZVpvb21pbmcgOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBvbmx5IHByb2NlZWQgaWYgQ1NTIHRyYW5zZm9ybXMgYXJlIHN1cHBvcnRlZFxuXHQvLyBORUVEIFRPIEZJWFxuXHRcdC8vaWYgKCAhTW9kZXJuaXpyLmNzc3RyYW5zZm9ybXMgKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHpvb21Db250ZW50ID0gJCgnLmlsbHVzdC1jb250YWluZXInKVswXTtcblxuXHRcdFpVSSA9IG5ldyBab29tZXIoem9vbUNvbnRlbnQpO1xuXG5cdFx0Ly9tYWtlIHN1cmUgcGFnZSBpcyBhdCB0aGUgdG9wIHdoZW4gcmVsb2FkZWRcblx0XHR3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG5cblx0Ly9vbiBwYWdlIGxvYWQgY2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gYW5kIHNjYWxlIHRvIGl0XG5cdFx0Ly8gWlVJLnJlY2FsY3VsYXRlUG9zaXRpb25zKCk7XG5cblx0fVxufTtcblxuLy8gdGhlIGNvbnN0cnVjdG9yIHRoYXQgd2lsbCBkbyBhbGwgdGhlIHdvcmtcbmZ1bmN0aW9uIFpvb21lciggY29udGVudCApIHtcblxuXHR0aGlzLnNldExldmVscyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMuZG9jV2lkdGggPiAxNTAwKSB7XG5cdFx0XHR0aGlzLmxldmVscyA9IDYuMjtcblx0XHRcdHRoaXMudmVydGljYWxUcmFuc2xhdGUgPSAzMDAwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5kb2NXaWR0aCA+IDEzNTApIHtcblx0XHRcdHRoaXMubGV2ZWxzID0gNjtcblx0XHRcdHRoaXMudmVydGljYWxUcmFuc2xhdGUgPSAyNzUwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5kb2NXaWR0aCA+IDEyNTApIHtcblx0XHRcdHRoaXMubGV2ZWxzID0gNS44O1xuXHRcdFx0dGhpcy52ZXJ0aWNhbFRyYW5zbGF0ZSA9IDI0NTA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmRvY1dpZHRoID4gMTE1MCkge1xuXHRcdFx0dGhpcy5sZXZlbHMgPSA1Ljc7XG5cdFx0XHR0aGlzLnZlcnRpY2FsVHJhbnNsYXRlID0gMjM1MDtcblx0XHR9IGVsc2UgaWYgKHRoaXMuZG9jV2lkdGggPiAxMDUwKSB7XG5cdFx0XHR0aGlzLmxldmVscyA9IDUuNTtcblx0XHRcdHRoaXMudmVydGljYWxUcmFuc2xhdGUgPSAyMTAwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5kb2NXaWR0aCA+IDk1MCkge1xuXHRcdFx0dGhpcy5sZXZlbHMgPSA1LjM1O1xuXHRcdFx0dGhpcy52ZXJ0aWNhbFRyYW5zbGF0ZSA9IDE5MDA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmRvY1dpZHRoID4gODUwKSB7XG5cdFx0XHR0aGlzLmxldmVscyA9IDUuMTU7XG5cdFx0XHR0aGlzLnZlcnRpY2FsVHJhbnNsYXRlID0gMTcwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sZXZlbHMgPSA0Ljk7XG5cdFx0XHR0aGlzLnZlcnRpY2FsVHJhbnNsYXRlID0gMTUyMDtcblx0XHR9XG5cblx0fTtcblxuXHQvLyBrZWVwIHRyYWNrIG9mIERPTVxuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXG5cdHRoaXMuaGVhZGVyID0gJCgnLnBhZ2UtaGVhZGVyJylbMF07XG5cdHRoaXMuYm9keSA9ICQoJ2JvZHknKVswXTtcblx0dGhpcy50b3duID0gJCgnLmlsbHVzdC1sZXZlbC0tdG93bicpWzBdO1xuXHR0aGlzLnRvd25TeW1ib2xzID0gJCgnLmlsbHVzdC1sZXZlbC0tc3ltYm9sc1Rvd24nKVswXTtcblx0dGhpcy5ob3VzZSA9ICQoJy5zdmctaG91c2UnKVswXTtcblx0dGhpcy5jYXJvbGxlcnMgPSAkKCcuc3ZnLWNhcm9sbGVycycpWzBdO1xuXHR0aGlzLnN0YXIgPSAkKCcuc3ZnLXN0YXInKVswXTtcblxuXHQvLyBwb3NpdGlvbiBvZiB2ZXJ0aWNhbCBzY3JvbGxcblx0dGhpcy5zY3JvbGxlZCA9IDA7XG5cblx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gaGVpZ2h0IG9mIGRvY3VtZW50XG5cdHRoaXMuZG9jSGVpZ2h0ID0gTWF0aC5tYXgoIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCApO1xuXHR0aGlzLmRvY1dpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcblxuXHQvLyB6ZXJvLWJhc2VkIG51bWJlciBvZiBzZWN0aW9uc1xuXHR0aGlzLnNldExldmVscygpO1xuXG5cblx0Ly8gYmluZCBab29tZXIgdG8gc2Nyb2xsIGV2ZW50XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcywgZmFsc2UpO1xufVxuXG4vLyBlbmFibGVzIGNvbnN0cnVjdG9yIHRvIGJlIHVzZWQgd2l0aGluIGV2ZW50IGxpc3RlbmVyXG4vLyBsaWtlIG9iai5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMsIGZhbHNlIClcblpvb21lci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdGlmICggdGhpc1tldmVudC50eXBlXSApIHtcblx0XHR0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcblx0fVxufTtcblxuLy8gdHJpZ2dlcmVkIGV2ZXJ5IHRpbWUgd2luZG93IHNjcm9sbHNcblpvb21lci5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdGlmIChVSS5zY3JvbGxBY3RpdmUpIHtcblx0XHR0aGlzLnJlY2FsY3VsYXRlUG9zaXRpb25zKCk7XG5cdH1cblxufTtcblxuWm9vbWVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuXHQvL0xFVFMgSEFWRSBTT01FIERFRkFVTFRTIEhFUkVcblx0dmFyIElOSVRJQUxfVE9XTl9XSURUSCA9IDM1MCxcblx0XHRJTklUSUFMX1RPV05fSEVJR0hUID0gMzIwLFxuXHRcdFRBUkdFVF9UT1dOX1dJRFRIID0gMjgwMCxcblx0XHRUQVJHRVRfVE9XTl9IRUlHSFQgPSAyNTYwLFxuXG5cdFx0VEFSR0VUX0JHX1pTQ0FMRSA9IDIwMCxcblxuXHRcdE9GRlNFVF9NQVJHSU4gPSA4MCxcblxuXHRcdFRBUkdFVF9WRVJUSUNBTF9UUkFOU0xBVEUgPSAyNjAwO1xuXG5cblx0dmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG5cdHZhciBpc0NTUzFDb21wYXQgPSAoKGRvY3VtZW50LmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiKTtcblxuXHR2YXIgeU9mZnNldCA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXG5cdC8vIG5vcm1hbGl6ZSBzY3JvbGwgdmFsdWUgZnJvbSAwIHRvIDFcblx0dGhpcy5zY3JvbGxlZCA9IHlPZmZzZXQgLyAoIHRoaXMuZG9jSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0ICk7XG5cblx0dmFyIHRyYW5zZm9ybVZhbHVlLFxuXHRcdHdpZHRoLFxuXHRcdHRyYW5zZm9ybVByZWZpeCxcblx0XHR0b3duVHJhbnNmb3JtLFxuXHRcdHN5bWJvbHRyYW5zZm9ybVZhbHVlO1xuXG5cdHRoaXMuY2hlY2tTdGF0ZXMoKTtcblxuXHR2YXIgc2Nyb2xsRmFjdG9yID0gKHRoaXMuc2Nyb2xsZWQgPCAwLjUgPyB0aGlzLnNjcm9sbGVkIDogMC41KTtcblx0dmFyIHNjYWxlID0gTWF0aC5wb3coIDMsIHNjcm9sbEZhY3RvciAqIHRoaXMubGV2ZWxzICk7XG5cdHZhciB0b3duSGVpZ2h0ID0gTWF0aC5yb3VuZChzY2FsZSAqIElOSVRJQUxfVE9XTl9IRUlHSFQpO1xuXHR2YXIgdG93bldpZHRoID0gTWF0aC5yb3VuZChzY2FsZSAqIElOSVRJQUxfVE9XTl9XSURUSCk7XG5cdHZhciB0b3duT2Zmc2V0ID0gTWF0aC5yb3VuZChzY2FsZSAqIE9GRlNFVF9NQVJHSU4pIC0gT0ZGU0VUX01BUkdJTjtcblxuXHQvL2ZpcnN0IGhhbGYgb2YgYXBwIGlzIHRoZSBzY2FsZSDigJMgdGhpcyB6b29tcyBpbnRvIHRoZSBob3VzZVxuXHRpZiAoc2Nyb2xsRmFjdG9yIDwgMC41KSB7XG5cblx0XHR2YXIgelNjYWxlID0gTWF0aC5yb3VuZCgoc2NhbGUgKiBUQVJHRVRfQkdfWlNDQUxFKSAtIFRBUkdFVF9CR19aU0NBTEUpO1xuXG5cdFx0dmFyIHRvd25ZUG9zID0gTWF0aC5yb3VuZCgoKHRvd25IZWlnaHQgLyAyKSArIHRvd25PZmZzZXQpKTtcblxuXHRcdC8vaWYgd2Ugc3VwcG9ydCB0cmFuc2xhdGUzZFxuXHRcdGlmIChVSS5zdXBwb3J0cy50cmFuc2Zvcm0zZCkge1xuXHRcdFx0dHJhbnNmb3JtVmFsdWUgPSAndHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoJyArIHNjYWxlICsgJyknO1xuXG5cdFx0XHR0b3duVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKC01MCUsIC0nICsgdG93bllQb3MgKyAncHgsIDApJztcblx0XHRcdHN5bWJvbHRyYW5zZm9ybVZhbHVlID0gJ3RyYW5zbGF0ZTNkKC0nICsgKHRvd25XaWR0aCAvIDIpICsgJ3B4LCAtJyArIHRvd25ZUG9zICsgJ3B4LCAwKScgKyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHJhbnNmb3JtVmFsdWUgPSAndHJhbnNsYXRlKDAsIDApIHNjYWxlKCcgKyBzY2FsZSArICcpJztcblxuXHRcdFx0dG93blRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgLScgKyB0b3duWVBvcyArICdweCknO1xuXHRcdFx0c3ltYm9sdHJhbnNmb3JtVmFsdWUgPSAndHJhbnNsYXRlKC0nICsgKHRvd25XaWR0aCAvIDIpICsgJ3B4LCAtJyArIHRvd25ZUG9zICsgJ3B4KScgKyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJztcblx0XHR9XG5cblx0Ly90aGUgc2Vjb25kIGhhbGYgaXMgdGhlIHRyYW5zbGF0ZSB2ZXJ0aWNhbGx5XG5cdH0gZWxzZSB7XG5cblx0XHR2YXIgcGVyY2VudGFnZVRocm91Z2hTZWN0aW9uID0gKCh0aGlzLnNjcm9sbGVkIC0gMC41KSAvIDAuNSk7IC8vZ2V0IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBhbW91bnQgdGhyb3VnaCB0aGUgc2VjdGlvbiAob24gYSBzY2FsZSAwLTEpXG5cdFx0dmFyIHZlcnRpY2FsVHJhbnNsYXRlID0gcGVyY2VudGFnZVRocm91Z2hTZWN0aW9uICogdGhpcy52ZXJ0aWNhbFRyYW5zbGF0ZTsgLy9nZXRzIGEgc2NhbGVkIGFtb3VudCBkZXBlbmRlbnQgb24gdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHNlY3Rpb24gc2Nyb2xsZWQgdGhyb3VnaFxuXG5cdFx0dmFyIHRvd25ZUG9zID0gTWF0aC5yb3VuZCgodG93bkhlaWdodCAvIDIpICsgdG93bk9mZnNldCAtIHZlcnRpY2FsVHJhbnNsYXRlKTtcblxuXHRcdC8vaWYgd2Ugc3VwcG9ydCB0cmFuc2xhdGUzZFxuXHRcdGlmIChVSS5zdXBwb3J0cy50cmFuc2Zvcm0zZCkge1xuXHRcdFx0dHJhbnNmb3JtVmFsdWUgPSAndHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoJyArIHNjYWxlICsgJyknO1xuXHRcdFx0dG93blRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgtNTAlLCAtJyArIHRvd25ZUG9zICsgJ3B4LCAwKSc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRyYW5zZm9ybVZhbHVlID0gJ3RyYW5zbGF0ZSgwLCAwKSBzY2FsZSgnICsgc2NhbGUgKyAnKSc7XG5cdFx0XHR0b3duVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtNTAlLCAtJyArIHRvd25ZUG9zICsgJ3B4KSc7XG5cdFx0fVxuXG5cdH1cblxuXHQvLyBTRVRUSU5HIE9GIE9VUiBORVcgVkFMVUVTXG5cblx0Ly91cGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0b3duXG5cdHRoaXMudG93bi5zdHlsZS53aWR0aCA9IHRvd25XaWR0aCArICdweCc7XG5cdHRoaXMudG93bi5zdHlsZS5oZWlnaHQgPSB0b3duSGVpZ2h0ICsgJ3B4JztcblxuXHQvLyAvL3VwZGF0ZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgZm9yIHRoZSB0b3duXG5cdHRoaXMudG93bi5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSB0b3duVHJhbnNmb3JtO1xuXHR0aGlzLnRvd24uc3R5bGUuTW96VHJhbnNmb3JtID0gdG93blRyYW5zZm9ybTtcblx0dGhpcy50b3duLnN0eWxlLm1zVHJhbnNmb3JtID0gdG93blRyYW5zZm9ybTtcblx0dGhpcy50b3duLnN0eWxlLnRyYW5zZm9ybSA9IHRvd25UcmFuc2Zvcm07XG5cblx0Ly8gLy91cGRhdGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvdXRzaWRlIGlsbHVzdHJhdGlvbnMgYW5kIHRleHRcblx0Ly8gaWYobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcblx0XHR0aGlzLmNvbnRlbnQuc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtVmFsdWU7XG5cdFx0dGhpcy5jb250ZW50LnN0eWxlLk1velRyYW5zZm9ybSA9IHRyYW5zZm9ybVZhbHVlO1xuXHRcdHRoaXMuY29udGVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zZm9ybVZhbHVlO1xuXHRcdHRoaXMuY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1WYWx1ZTtcblx0Ly8gfVxuXG5cdC8vIC8vdG93biBzeW1ib2xzIHNjYWxpbmdcblx0dGhpcy50b3duU3ltYm9scy5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJyknO1xuXHR0aGlzLnRvd25TeW1ib2xzLnN0eWxlLk1velRyYW5zZm9ybSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnKSc7XG5cdHRoaXMudG93blN5bWJvbHMuc3R5bGUubXNUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJyknO1xuXHR0aGlzLnRvd25TeW1ib2xzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnKSc7XG5cbn07XG5cblxuWm9vbWVyLnByb3RvdHlwZS5jaGVja1N0YXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAodGhpcy5zY3JvbGxlZCA+IDApIHtcblx0XHR0aGlzLmhlYWRlci5jbGFzc0xpc3QuYWRkKCdzY2FsZWQnKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmhlYWRlci5jbGFzc0xpc3QucmVtb3ZlKCdzY2FsZWQnKTtcblx0fVxuXG5cdC8vZG8gYSB0ZXN0IHdoZXRoZXIgdG8gc3dpdGNoIHRvIG5pZ2h0IG9yIG5vdCAoYWZ0ZXIgMC4yNSBzY3JvbGxlZClcblx0aWYgKHRoaXMuc2Nyb2xsZWQgPiAwLjE1KSB7XG5cdFx0dGhpcy5ib2R5LmNsYXNzTGlzdC5hZGQoJ25pZ2h0Jyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ25pZ2h0Jyk7XG5cdH1cblxuXHQvL3Rlc3QgYmV0d2VlbiBzdGF0ZSBvZiBtb3ZlbWVudFxuXHRpZiAodGhpcy5zY3JvbGxlZCA8IDAuNSkge1xuXG5cdFx0dGhpcy5ob3VzZS5jbGFzc0xpc3QucmVtb3ZlKCdpbmFjdGl2ZScpOyAvL21ha2UgaG91c2UgdmlzaWJsZVxuXHRcdHRoaXMuY2Fyb2xsZXJzLmNsYXNzTGlzdC5yZW1vdmUoJ2luYWN0aXZlJyk7IC8vbWFrZSBjYXJvbGxlcnMgaW52aXNpYmxlXG5cdFx0dGhpcy5zdGFyLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlJyk7IC8vbWFrZSBjYXJvbGxlcnMgaW52aXNpYmxlXG5cdFx0dGhpcy50b3duU3ltYm9scy5xdWVyeVNlbGVjdG9yKCcuc3ltYm9scy0taW5zaWRlJykuY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKTsgLy9tYWtlIG5hdGl2aXR5IHN5bWJvbHMgbm90IHZpc2libGVcblx0XHR0aGlzLnRvd25TeW1ib2xzLnF1ZXJ5U2VsZWN0b3IoJy5zeW1ib2xzLS1vdXRzaWRlJykuY2xhc3NMaXN0LnJlbW92ZSgnaW5hY3RpdmUnKTsgLy9tYWtlIG5hdGl2aXR5IHN5bWJvbHMgbm90IHZpc2libGVcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5ob3VzZS5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpOyAvL21ha2UgaG91c2Ugbm90IHZpc2libGVcblx0XHR0aGlzLmNhcm9sbGVycy5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZScpOyAvL21ha2UgY2Fyb2xsZXJzIGludmlzaWJsZVxuXHRcdHRoaXMuc3Rhci5jbGFzc0xpc3QucmVtb3ZlKCdpbmFjdGl2ZScpOyAvL21ha2UgY2Fyb2xsZXJzIGludmlzaWJsZVxuXHRcdHRoaXMudG93blN5bWJvbHMucXVlcnlTZWxlY3RvcignLnN5bWJvbHMtLWluc2lkZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2luYWN0aXZlJyk7IC8vbWFrZSBuYXRpdml0eSBzeW1ib2xzIHZpc2libGVcblx0XHR0aGlzLnRvd25TeW1ib2xzLnF1ZXJ5U2VsZWN0b3IoJy5zeW1ib2xzLS1vdXRzaWRlJykuY2xhc3NMaXN0LmFkZCgnaW5hY3RpdmUnKTsgLy9tYWtlIG5hdGl2aXR5IHN5bWJvbHMgbm90IHZpc2libGVcblxuXHR9XG5cbn07XG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gVUk7IiwiLypcdEF1dGhvcjpcblx0XHRUTVcgLSAoQXV0aG9yIE5hbWUgSGVyZSlcbiovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuLy8gREVGSU5FIEdMT0JBTCBMSUJTICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbi8vIFVuY29tbWVudCB0aGUgbGluZSBiZWxvdyB0byBleHBvc2UgalF1ZXJ5IGFzIGEgZ2xvYmFsIG9iamVjdCB0byB0aGUgdXN1YWwgcGxhY2VzXG4vLyB3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSByZXF1aXJlKCcuL2xpYnMvanF1ZXJ5L2pxdWVyeS0xLjEwLjIuanMnKTtcblxuLy8gZm9yY2UgY29tcGlsYXRpb24gb2YgZ2xvYmFsIGxpYnMgdGhhdCBkb24ndCByZXR1cm4gYSB2YWx1ZS5cbnJlcXVpcmUoXCIuL2hlbHBlcnMvbG9nXCIpO1xucmVxdWlyZShcIi4vaGVscGVycy9zaGltc1wiKTtcblxuXG4vL2luaXRpYWxpc2UgS08gb2JqZWN0XG52YXIgS08gPSB3aW5kb3cuS08gPSB7fTtcblxuS08uU29ja2V0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9zb2NrZXRzJyk7XG5LTy5VSSA9IHJlcXVpcmUoJy4vbW9kdWxlcy91aScpO1xuXG5LTy5Db25maWcgPSB7XG5cblx0aW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRLTy5VSS5pbml0KCk7XG5cdFx0S08uU29ja2V0cy5pbml0KCk7XG5cdH1cbn07XG5cblxuS08uQ29uZmlnLmluaXQoKTsiXX0=
